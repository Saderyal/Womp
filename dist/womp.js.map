{
  "version": 3,
  "sources": ["../ts/womp.ts"],
  "sourcesContent": ["export interface WompProps {\n\tchildren?: NodeList;\n\t[key: string]: any;\n}\n\nexport interface RenderHtml {\n\tparts: TemplateStringsArray;\n\tvalues: any[];\n\t__womp: true;\n}\n\nexport interface WompComponent {\n\t(props: WompProps): RenderHtml;\n\tcomponentName: string;\n\tcss: string;\n}\n\ntype State = [any, (newValue: any) => void];\n\ninterface Effect {\n\tdependencies: any;\n\tcallback: VoidFunction | (() => VoidFunction);\n\tcleanupFunction: VoidFunction | void;\n}\n\nexport interface WompElement extends HTMLElement {\n\tstate: State[];\n\teffects: Effect[];\n\tprops: { [key: string]: any };\n\trequestRender: () => void;\n}\n\ninterface WompElementClass {\n\tnew (): any;\n\tcachedTemplate: CachedTemplate;\n\tgetOrCreateTemplate(parts: TemplateStringsArray): CachedTemplate;\n}\n\ninterface Dependency {\n\ttype: number;\n\tindex: number;\n\tname?: string;\n\tattrDynamics?: string;\n}\n\n/* \n================================================\nSTART WOMP\n================================================\n*/\n\nconst DEV_MODE = true;\n\nlet currentRenderingComponent: WompElement = null;\nlet currentHookIndex: number = 0;\nlet currentEffectIndex: number = 0;\nconst WC_MARKER = '$wc$';\nconst isAttrRegex = /\\s+([^\\s]*?)=\"?$/g;\nconst selfClosingRegex = /(<([a-x]*?-[a-z]*).*?)\\/>/g;\nconst isInsideTextTag = /<(?<tag>script|style|textarea|title])(?!.*?<\\/\\k<tag>)/gi;\nconst onlyTextChildrenElementsRegex = /^(?:script|style|textarea|title)$/i;\n\nconst NODE = 0;\nconst ATTR = 1;\n\nconst treeWalker = document.createTreeWalker(\n\tdocument,\n\t129 // NodeFilter.SHOW_{ELEMENT|COMMENT}\n);\n\n/**\n * Generates the static styles of a component.\n * @returns The generated styles specific to the component\n */\nconst generateSpecifcStyles = (\n\tcomponent: WompComponent\n): [string, { [className: string]: string }] => {\n\tconst componentCss = component.css || '';\n\tif (DEV_MODE) {\n\t\tconst invalidSelectors: string[] = [];\n\t\t// It's appropriate that at least one class is present in each selector\n\t\t[...componentCss.matchAll(/.*?}([\\s\\S]*?){/gm)].forEach((selector) => {\n\t\t\tconst cssSelector = selector[1].trim();\n\t\t\tif (!cssSelector.includes('.')) invalidSelectors.push(cssSelector);\n\t\t});\n\t\tinvalidSelectors.forEach((selector) => {\n\t\t\tconsole.warn(\n\t\t\t\t`The CSS selector \"${selector} {...}\" in the component \"${component.componentName}\" is not enough specific: include at least one class.\\n`\n\t\t\t);\n\t\t});\n\t}\n\tconst classNames = new Set<string>();\n\t[...componentCss.matchAll(/\\.(.*?)[\\s|{]/gm)].forEach((match) => {\n\t\tconst className = match[1];\n\t\tclassNames.add(className);\n\t});\n\tlet generatedCss = componentCss;\n\tconst classes: { [key: string]: string } = {};\n\tclassNames.forEach((className) => {\n\t\tconst uniqueClassName = `${component.componentName}__${className}`;\n\t\tgeneratedCss = generatedCss.replaceAll(className, uniqueClassName);\n\t\tclasses[className] = uniqueClassName;\n\t});\n\treturn [generatedCss, classes];\n};\n\n//* OK\n//! HTML Nested fare il \"join\" delle dependencies\nconst createHtml = (parts: TemplateStringsArray): [string, string[]] => {\n\tlet html = '';\n\tconst attributes = [];\n\tconst length = parts.length - 1;\n\tlet attrDelimiter = '';\n\tlet textTagName = '';\n\tfor (let i = 0; i < length; i++) {\n\t\tlet part = parts[i];\n\t\t// End of values inside an attribute\n\t\tif (attrDelimiter && part.includes(attrDelimiter)) attrDelimiter = '';\n\t\t// End of values inside a text node (script, textarea, title, style)\n\t\tif (textTagName && new RegExp(`<\\/${textTagName}>`)) textTagName = '';\n\t\tif (attrDelimiter || textTagName) {\n\t\t\t// We are inside an attribute\n\t\t\thtml += part + WC_MARKER;\n\t\t} else {\n\t\t\t// If the Regex is global, it will start from the index past the end of the last match.\n\t\t\tisAttrRegex.lastIndex = 0;\n\t\t\tconst isAttr = isAttrRegex.exec(part);\n\t\t\tif (isAttr) {\n\t\t\t\tconst [match, attrName] = isAttr;\n\t\t\t\tconst beforeLastChar = match[match.length - 1];\n\t\t\t\tattrDelimiter = beforeLastChar === '\"' || beforeLastChar === \"'\" ? beforeLastChar : '';\n\t\t\t\tpart = part.substring(0, part.length - attrDelimiter.length - 1);\n\t\t\t\tlet toAdd = `${part}${WC_MARKER}=`;\n\t\t\t\tif (attrDelimiter) toAdd += `${attrDelimiter}${WC_MARKER}`;\n\t\t\t\telse toAdd += '\"0\"';\n\t\t\t\thtml += toAdd;\n\t\t\t\tattributes.push(attrName);\n\t\t\t} else {\n\t\t\t\tisInsideTextTag.lastIndex = 0;\n\t\t\t\tconst insideTextTag = isInsideTextTag.exec(part);\n\t\t\t\tif (insideTextTag) {\n\t\t\t\t\ttextTagName = insideTextTag[1];\n\t\t\t\t\thtml += part + WC_MARKER;\n\t\t\t\t} else {\n\t\t\t\t\t// It's a child node\n\t\t\t\t\thtml += part + `<?${WC_MARKER}>`;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\thtml += parts[parts.length - 1];\n\thtml = html.replace(selfClosingRegex, '$1></$2>');\n\treturn [html, attributes];\n};\n\nconst createDependencies = (\n\ttemplate: HTMLTemplateElement,\n\tparts: TemplateStringsArray,\n\tattributes: string[]\n) => {\n\tconst dependencies = [];\n\ttreeWalker.currentNode = template.content;\n\tlet node: Element;\n\tlet dependencyIndex = 0;\n\tlet nodeIndex = 0;\n\tconst partsLength = parts.length;\n\twhile (((node as Node) = treeWalker.nextNode()) !== null && dependencies.length < partsLength) {\n\t\t// Is a \"normal\" node\n\t\tif (node.nodeType === 1) {\n\t\t\tif (node.hasAttributes()) {\n\t\t\t\tconst attributeNames = node.getAttributeNames();\n\t\t\t\tfor (const attrName of attributeNames) {\n\t\t\t\t\tif (attrName.endsWith(WC_MARKER)) {\n\t\t\t\t\t\tconst realName = attributes[dependencyIndex++];\n\t\t\t\t\t\tconst attrValue = node.getAttribute(attrName);\n\t\t\t\t\t\tif (attrValue !== '0') {\n\t\t\t\t\t\t\tconst dynamicParts = attrValue.split(WC_MARKER);\n\t\t\t\t\t\t\tfor (let i = 0; i < dynamicParts.length - 1; i++) {\n\t\t\t\t\t\t\t\tconst dependency: Dependency = {\n\t\t\t\t\t\t\t\t\ttype: ATTR,\n\t\t\t\t\t\t\t\t\tindex: nodeIndex,\n\t\t\t\t\t\t\t\t\tattrDynamics: attrValue,\n\t\t\t\t\t\t\t\t\tname: realName,\n\t\t\t\t\t\t\t\t};\n\t\t\t\t\t\t\t\tdependencies.push(dependency);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tconst dependency: Dependency = {\n\t\t\t\t\t\t\t\ttype: ATTR,\n\t\t\t\t\t\t\t\tindex: nodeIndex,\n\t\t\t\t\t\t\t\tname: realName,\n\t\t\t\t\t\t\t};\n\t\t\t\t\t\t\tdependencies.push(dependency);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tnode.removeAttribute(attrName);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t// A text node should be created for each dynamic part inside of\n\t\t\t// nodes that only have text nodes inside (script, style, textarea, title).\n\t\t\tif (onlyTextChildrenElementsRegex.test(node.tagName)) {\n\t\t\t\tconst strings = node.textContent!.split(WC_MARKER);\n\t\t\t\tconst lastIndex = strings.length - 1;\n\t\t\t\tif (lastIndex > 0) {\n\t\t\t\t\tnode.textContent = '';\n\t\t\t\t\tfor (let i = 0; i < lastIndex; i++) {\n\t\t\t\t\t\tnode.append(strings[i], document.createComment(''));\n\t\t\t\t\t\t// Walk past the marker node we just added\n\t\t\t\t\t\ttreeWalker.nextNode();\n\t\t\t\t\t\tdependencies.push({ type: NODE, index: ++nodeIndex });\n\t\t\t\t\t}\n\t\t\t\t\t// Because this marker is added after the walker's current\n\t\t\t\t\t// node, it will be walked to in the outer loop (and ignored), so\n\t\t\t\t\t// we don't need to adjust nodeIndex here\n\t\t\t\t\tnode.append(strings[lastIndex], document.createComment(''));\n\t\t\t\t}\n\t\t\t}\n\t\t} else if (node.nodeType === 8) {\n\t\t\t// Is a comment\n\t\t\tconst data = (node as unknown as Comment).data;\n\t\t\tif (data === `?${WC_MARKER}`) {\n\t\t\t\tdependencies.push({ type: NODE, index: nodeIndex });\n\t\t\t} else {\n\t\t\t\t//! Capisci sta roba\n\t\t\t\t// let i = -1;\n\t\t\t\t// while ((i = (node as unknown as Comment).data.indexOf(WC_MARKER, i + 1)) !== -1) {\n\t\t\t\t// \t// Comment node has a binding marker inside, make an inactive part\n\t\t\t\t// \t// The binding won't work, but subsequent bindings will\n\t\t\t\t// \tdependencies.push({ type: COMMENT_PART, index: nodeIndex });\n\t\t\t\t// \t// Move to the end of the match\n\t\t\t\t// \ti += WC_MARKER.length - 1;\n\t\t\t\t// }\n\t\t\t}\n\t\t}\n\t\tnodeIndex++;\n\t}\n\treturn dependencies;\n};\n\nclass DynamicNode {\n\tpublic startNode: ChildNode;\n\tpublic endNode: ChildNode | null;\n\tpublic index: number;\n\tpublic isNode: true = true; // For faster access\n\n\tconstructor(startNode: ChildNode, endNode: ChildNode | null, index: number) {\n\t\tthis.startNode = startNode;\n\t\tthis.endNode = endNode;\n\t\tthis.index = index;\n\t}\n}\n\nclass DynamicAttribute {\n\tpublic node: HTMLElement;\n\tpublic name: string;\n\tpublic index: number;\n\tpublic isNode: false = false; // For faster access\n\tpublic attrStructure: string;\n\n\tprivate _callback: (event: Event) => void;\n\tprivate eventInitialized = false;\n\n\tconstructor(node: HTMLElement, dependency: Dependency) {\n\t\tthis.node = node;\n\t\tthis.name = dependency.name;\n\t\tthis.index = dependency.index;\n\t\tthis.attrStructure = dependency.attrDynamics;\n\t}\n\n\tset callback(callback: (event: Event) => void) {\n\t\tif (!this.eventInitialized) {\n\t\t\tconst eventName = this.name.substring(1);\n\t\t\tthis.node.addEventListener(eventName, this.listener.bind(this));\n\t\t\tthis.eventInitialized = true;\n\t\t}\n\t\tthis._callback = callback;\n\t}\n\n\tprivate listener(event: Event) {\n\t\tif (this._callback) this._callback(event);\n\t}\n}\n\nclass CachedTemplate {\n\tpublic template: HTMLTemplateElement;\n\tpublic dependencies: Dependency[];\n\n\tconstructor(template: HTMLTemplateElement, dependencies: Dependency[]) {\n\t\tthis.template = template;\n\t\tthis.dependencies = dependencies;\n\t}\n\n\tpublic clone(): [DocumentFragment, (DynamicNode | DynamicAttribute)[]] {\n\t\tconst content = this.template.content;\n\t\tconst dependencies = this.dependencies;\n\t\tconst fragment = document.importNode(content, true);\n\t\ttreeWalker.currentNode = fragment;\n\t\tlet node = treeWalker.nextNode();\n\t\tlet nodeIndex = 0;\n\t\tlet dynamicIndex = 0;\n\t\tlet templateDependency = dependencies[0];\n\t\tconst dynamics = [];\n\t\twhile (templateDependency !== undefined) {\n\t\t\tif (nodeIndex === templateDependency.index) {\n\t\t\t\tlet dynamic: DynamicNode | DynamicAttribute;\n\t\t\t\tif (templateDependency.type === NODE) {\n\t\t\t\t\tdynamic = new DynamicNode(\n\t\t\t\t\t\tnode as HTMLElement,\n\t\t\t\t\t\tnode.nextSibling,\n\t\t\t\t\t\ttemplateDependency.index\n\t\t\t\t\t);\n\t\t\t\t} else if (templateDependency.type === ATTR) {\n\t\t\t\t\tdynamic = new DynamicAttribute(node as HTMLElement, templateDependency);\n\t\t\t\t}\n\t\t\t\tdynamics.push(dynamic);\n\t\t\t\ttemplateDependency = dependencies[++dynamicIndex];\n\t\t\t}\n\t\t\tif (nodeIndex !== templateDependency?.index) {\n\t\t\t\tnode = treeWalker.nextNode()!;\n\t\t\t\tnodeIndex++;\n\t\t\t}\n\t\t}\n\t\ttreeWalker.currentNode = document;\n\t\treturn [fragment, dynamics];\n\t}\n}\n\nconst setValues = (\n\tdynamics: (DynamicNode | DynamicAttribute)[],\n\tvalues: any[],\n\toldValues: any[]\n) => {\n\tfor (let i = 0; i < dynamics.length; i++) {\n\t\tconst currentDependency = dynamics[i];\n\t\tconst currentValue = values[i];\n\t\tif (currentValue === oldValues[i] && !(currentDependency as DynamicAttribute).attrStructure)\n\t\t\tcontinue;\n\t\tif (currentDependency.isNode) {\n\t\t\t// Updated elements\n\t\t\tlet newNodesList: any[] | NodeList | HTMLCollection = [currentValue];\n\t\t\tif (currentValue instanceof NodeList || currentValue instanceof HTMLCollection)\n\t\t\t\tnewNodesList = currentValue;\n\t\t\tlet prevNode = currentDependency.startNode;\n\t\t\tlet currentNode = prevNode.nextSibling;\n\t\t\tlet newNodeIndex = 0;\n\t\t\tlet index = 0;\n\t\t\tconst newNodesLength = newNodesList.length;\n\t\t\twhile (currentNode !== currentDependency.endNode) {\n\t\t\t\tconst newNode = newNodesList[newNodeIndex];\n\t\t\t\tconst next = currentNode.nextSibling;\n\t\t\t\tconst isNode = newNode instanceof Node;\n\t\t\t\t// Dont add the node if the value is false or if the newNode is undefined\n\t\t\t\tif (newNode === undefined || newNode === false) currentNode.remove();\n\t\t\t\telse if ((isNode && !currentNode.isEqualNode(newNode)) || !isNode) {\n\t\t\t\t\tcurrentNode.replaceWith(newNode);\n\t\t\t\t\tif (!isNode) newNodeIndex++; // So it doesn't change\n\t\t\t\t}\n\t\t\t\tprevNode = currentNode;\n\t\t\t\tcurrentNode = next;\n\t\t\t\tindex++;\n\t\t\t}\n\t\t\t// Exceed elements must be added\n\t\t\twhile (index < newNodesLength) {\n\t\t\t\tif (!currentNode || index === 0) currentNode = prevNode;\n\t\t\t\tconst newNode = newNodesList[newNodeIndex];\n\t\t\t\tconst isNode = newNode instanceof Node;\n\t\t\t\tif (newNode !== false) {\n\t\t\t\t\tif (!isNode) newNodeIndex++;\n\t\t\t\t\tcurrentNode.after(newNode);\n\t\t\t\t}\n\t\t\t\tcurrentNode = currentNode.nextSibling;\n\t\t\t\tindex++;\n\t\t\t}\n\t\t} else if (currentDependency.isNode === false) {\n\t\t\tconst attrName = currentDependency.name;\n\t\t\tif (attrName.startsWith('@')) {\n\t\t\t\tcurrentDependency.callback = currentValue;\n\t\t\t} else {\n\t\t\t\tconst node = currentDependency.node;\n\t\t\t\tconst attrStructure = currentDependency.attrStructure;\n\t\t\t\tif (attrStructure) {\n\t\t\t\t\tconst parts = attrStructure.split(WC_MARKER);\n\t\t\t\t\tlet dynamicValue = currentValue;\n\t\t\t\t\tfor (let j = 0; j < parts.length - 1; j++) {\n\t\t\t\t\t\tparts[j] = `${parts[j]}${dynamicValue}`;\n\t\t\t\t\t\ti++; // Go to the next dynamic value\n\t\t\t\t\t\tdynamicValue = values[i];\n\t\t\t\t\t}\n\t\t\t\t\ti--; // Since it'll be already increased in the loop, decrease by one\n\t\t\t\t\tnode.setAttribute(attrName, parts.join('').trim());\n\t\t\t\t} else if (currentValue === false) node.removeAttribute(attrName);\n\t\t\t\telse node.setAttribute(attrName, currentValue);\n\t\t\t}\n\t\t}\n\t}\n};\n\nconst womp = (Component: WompComponent): WompElementClass => {\n\tconst [generatedCSS, styles] = generateSpecifcStyles(Component);\n\tconst style = document.createElement('style');\n\tstyle.textContent = generatedCSS;\n\tdocument.body.appendChild(style); //! Check where to attach styles: if shadow-dom, inside the element\n\tconst WompComponent = class extends HTMLElement implements WompElement {\n\t\tstate: any[] = [];\n\t\teffects: any[] = [];\n\t\tprops: { [key: string]: any } = {};\n\n\t\tprivate ROOT: this | ShadowRoot;\n\t\tprivate dynamics: (DynamicNode | DynamicAttribute)[];\n\t\tprivate updating: boolean = false;\n\t\tprivate oldValues: any[];\n\n\t\tstatic cachedTemplate: CachedTemplate;\n\n\t\tstatic getOrCreateTemplate(parts: TemplateStringsArray) {\n\t\t\tif (!this.cachedTemplate) {\n\t\t\t\tconst [dom, attributes] = createHtml(parts);\n\t\t\t\tconst template = document.createElement('template');\n\t\t\t\ttemplate.innerHTML = dom;\n\t\t\t\tconst dependencies = createDependencies(template, parts, attributes);\n\t\t\t\tthis.cachedTemplate = new CachedTemplate(template, dependencies);\n\t\t\t}\n\t\t\treturn this.cachedTemplate;\n\t\t}\n\n\t\tconstructor() {\n\t\t\tsuper();\n\t\t\tthis.initElement();\n\t\t}\n\n\t\t/** @override component is connected to DOM */\n\t\tconnectedCallback() {}\n\n\t\t/**\n\t\t * Initializes the component with the state, props, and styles.\n\t\t */\n\t\tprivate initElement() {\n\t\t\tthis.ROOT = this;\n\t\t\tthis.ROOT.innerHTML = '';\n\t\t\tthis.oldValues = [];\n\t\t\tthis.props = {\n\t\t\t\t...this.props,\n\t\t\t\tstyles: styles,\n\t\t\t};\n\t\t\tcurrentRenderingComponent = this;\n\t\t\tcurrentHookIndex = 0;\n\t\t\tcurrentEffectIndex = 0;\n\t\t\tconst renderHtml = this.getRenderData();\n\t\t\tconst { values, parts } = renderHtml;\n\t\t\tconst template = (this.constructor as typeof WompComponent).getOrCreateTemplate(parts);\n\t\t\tconst [fragment, dynamics] = template.clone();\n\t\t\tthis.dynamics = dynamics;\n\t\t\tsetValues(this.dynamics, values, this.oldValues);\n\t\t\twhile (fragment.childNodes.length) {\n\t\t\t\tthis.ROOT.appendChild(fragment.childNodes[0]);\n\t\t\t}\n\t\t}\n\n\t\tprivate getRenderData() {\n\t\t\tconst result = Component(this.props);\n\t\t\tlet renderHtml: RenderHtml = result as RenderHtml;\n\t\t\tif (typeof result === 'string' || result instanceof HTMLElement) renderHtml = html`${result}`;\n\t\t\treturn renderHtml;\n\t\t}\n\n\t\tpublic requestRender() {\n\t\t\t//! Maybe improve re-rendering\n\t\t\tif (!this.updating) {\n\t\t\t\tthis.updating = true;\n\t\t\t\tPromise.resolve().then(() => {\n\t\t\t\t\tcurrentHookIndex = 0;\n\t\t\t\t\tcurrentEffectIndex = 0;\n\t\t\t\t\tcurrentRenderingComponent = this;\n\t\t\t\t\tconst renderHtml = this.getRenderData();\n\t\t\t\t\tsetValues(this.dynamics, renderHtml.values, this.oldValues);\n\t\t\t\t\tthis.oldValues = renderHtml.values;\n\t\t\t\t\tthis.updating = false;\n\t\t\t\t});\n\t\t\t}\n\t\t}\n\t};\n\n\treturn WompComponent;\n};\n\nexport function defineWomp(component: WompComponent) {\n\tconst Component = womp(component);\n\tcustomElements.define(component.componentName, Component);\n\treturn Component;\n}\n\n/* \n================================================\nHOOKS\n================================================\n*/\n\nexport const useState = <State>(defaultValue: State) => {\n\tconst component = currentRenderingComponent;\n\tif (!component.state.hasOwnProperty(currentHookIndex)) {\n\t\tconst index = currentHookIndex;\n\t\tcomponent.state[index] = [\n\t\t\tdefaultValue,\n\t\t\t(newValue: State) => {\n\t\t\t\tlet computedValue = newValue;\n\t\t\t\tif (typeof newValue === 'function') {\n\t\t\t\t\tcomputedValue = newValue(component.state[index][0]);\n\t\t\t\t}\n\t\t\t\tif (computedValue !== component.state[index][0]) {\n\t\t\t\t\tcomponent.state[index][0] = computedValue;\n\t\t\t\t\tcomponent.requestRender();\n\t\t\t\t}\n\t\t\t},\n\t\t];\n\t}\n\tconst state = component.state[currentHookIndex];\n\tcurrentHookIndex++;\n\treturn state;\n};\n\nexport const useEffect = (callback: VoidFunction | (() => VoidFunction), dependencies: any[]) => {\n\tconst component = currentRenderingComponent;\n\tif (!component.effects.hasOwnProperty(currentEffectIndex)) {\n\t\tconst index = currentEffectIndex;\n\t\tconst cleanupFunction = callback();\n\t\tcomponent.effects[index] = {\n\t\t\tdependencies: dependencies,\n\t\t\tcallback: callback,\n\t\t\tcleanupFunction: cleanupFunction,\n\t\t};\n\t} else {\n\t\tconst componentEffect = component.effects[currentEffectIndex];\n\t\tfor (let i = 0; i < dependencies.length; i++) {\n\t\t\tconst oldDep = componentEffect.dependencies[i];\n\t\t\tif (oldDep !== dependencies[i]) {\n\t\t\t\tif (componentEffect.cleanupFunction) componentEffect.cleanupFunction();\n\t\t\t\tcomponentEffect.cleanupFunction = callback();\n\t\t\t\tcomponentEffect.dependencies = dependencies;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tcurrentEffectIndex++;\n};\n\n/* \n================================================\nHTML\n================================================\n*/\n\n/**\n * Elaborate the string representation of the rendering content of the component.\n *\n * This function must be called without the use of the parentheses, like in the following example:\n *\n * @example\n * ```javascript\n * render(){\n *   return html`<div>Hello World!</div>`;\n * }\n * ```\n * @param template The list of string to concatenate with the values\n * @param values The list of values to concatenate with the templates\n */\nexport function html(templateParts: TemplateStringsArray, ...values: any[]): RenderHtml {\n\treturn {\n\t\tparts: templateParts,\n\t\tvalues: values,\n\t\t__womp: true,\n\t};\n}\n"],
  "mappings": "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",
  "names": ["html"]
}
