const ne=!1;let C=null,$=0;const _="$wc$",w="wc-wc",L=/<\/?$/g,v=/\s+([^\s]*?)="?$/g;//! Can cause problems. You should put also the "s" modifier
const F=/(<([a-z]*?-[a-z]*).*?)\/>/g,H=/<(?<tag>script|style|textarea|title])(?!.*?<\/\k<tag>)/gi,z=/^(?:script|style|textarea|title)$/i,E=0,S=1,P=2,N=typeof global<"u",T=N?{createTreeWalker(){}}:document,g=T.createTreeWalker(T,129);class q{constructor(e,n,o){this.template=e,this.dependencies=n,this.stringified=o}clone(){const e=this.template.content,n=this.dependencies,o=document.importNode(e,!0);g.currentNode=o;let t=g.nextNode(),a=0,i=0,r=n[0];const c=[];for(;r!==void 0;){if(a===r.index){let l;const d=r.type;d===E?l=new W(t,t.nextSibling):d===S?l=new U(t,r):d===P&&(l=new G(t)),c.push(l),r=n[++i]}a!==r?.index&&(t=g.nextNode(),a++)}return g.currentNode=document,[o,c]}}class j{constructor(e,n,o){this.stringifiedTemplate=e,this.values=n,this.template=o}}class W{constructor(e,n){this.isNode=!0;this.isAttr=!1;this.isTag=!1;this.startNode=e,this.endNode=n}clearValue(){let e=this.startNode.nextSibling;for(;e!==this.endNode;)e.remove(),e=this.startNode.nextSibling}dispose(){this.clearValue(),this.startNode.remove(),this.endNode.remove()}}class U{constructor(e,n){this.isNode=!1;this.isAttr=!0;this.isTag=!1;this.__eventInitialized=!1;this.node=e,this.name=n.name,this.attrStructure=n.attrDynamics}updateValue(e){if(this.name==="ref"&&e.__wcRef){if(e.current=this.node,this.node._$womp){const t=this.node.onDisconnected;this.node.onDisconnected=()=>{e.current=null,t()}}return}const n=this.node._$womp;n&&this.node.updateProps(this.name,e);const o=e!==Object(e);if(e===!1)this.node.removeAttribute(this.name);else if(o&&!this.name.match(/[A-Z]/))this.node.setAttribute(this.name,e);else if(this.name==="style"){let t="";const a=Object.keys(e);for(const i of a){let r=e[i],c=i.replace(/[A-Z]/g,l=>"-"+l.toLowerCase());typeof r=="number"&&(r=`${r}px`),t+=`${c}:${r};`}this.node.setAttribute(this.name,t)}this.name==="title"&&n&&this.node.removeAttribute(this.name)}set callback(e){if(!this.__eventInitialized){const n=this.name.substring(1);this.node.addEventListener(n,this.__listener.bind(this)),this.__eventInitialized=!0}this.__callback=e}__listener(e){this.__callback&&this.__callback(e)}}class G{constructor(e){this.isNode=!1;this.isAttr=!1;this.isTag=!0;this.node=e}}class B{constructor(e){this._$wompChildren=!0;this.nodes=e}}class Z{constructor(e,n){this.isArrayDependency=!0;this.dynamics=[],this.__parentDependency=n,this.addDependenciesFrom(n.startNode,e.length),this.__oldValues=b(this.dynamics,e,[])}addDependenciesFrom(e,n){let o=e,t=n;for(;t;){const a=document.createComment("?START"),i=document.createComment("?END");o.after(a),a.after(i);const r=new W(a,i);o=i,this.dynamics.push(r),t--}}checkUpdates(e){let n=e.length-this.__oldValues.length;if(n>0){let o=this.dynamics[this.dynamics.length-1]?.endNode;o||(o=this.__parentDependency.startNode),this.addDependenciesFrom(o,n)}else if(n<0)for(;n;)this.dynamics.pop().dispose(),n++;return this.__oldValues=b(this.dynamics,e,this.__oldValues),this}}const K=(s,e)=>{const{css:n}=s,{shadow:o,name:t,cssGeneration:a}=e,i=t,r={};let c=n;if(a){if(n.includes(":host")||(c=`${o?":host":i} {display:block;} ${n}`),0){//! Some valid selectors are marked as invalid e.g. :host/componentName, @media, etc.
}o||(c=c.replace(/:host/g,i)),c=c.replace(/\.(?!\d)([_a-zA-Z0-9-]+)/gm,(l,d)=>{const m=`${i}__${d}`;return r[d]=m,`.${m}`})}return[c,r]},Y=s=>{let e="";const n=[],o=s.length-1;let t="",a="";for(let i=0;i<o;i++){let r=s[i];if(t&&r.includes(t)&&(t=""),a&&new RegExp(`</${a}>`)&&(a=""),t||a)e+=r+_;else{v.lastIndex=0;const c=v.exec(r);if(c){const[l,d]=c,m=l[l.length-1];t=m==='"'||m==="'"?m:"",r=r.substring(0,r.length-t.length-1);let p=`${r}${_}=`;t?p+=`${t}${_}`:p+='"0"',e+=p,n.push(d)}else{if(r.match(L)){e+=r+w;continue}H.lastIndex=0;const l=H.exec(r);l?(a=l[1],e+=r+_):e+=r+`<?${_}>`}}}return e+=s[s.length-1],e=e.replace(F,"$1></$2>"),[e,n]},J=(s,e,n)=>{const o=[];g.currentNode=s.content;let t,a=0,i=0;const r=e.length;for(;(t=g.nextNode())!==null&&o.length<r;){if(t.nodeType===1){if(t.nodeName===w.toUpperCase()){const c={type:P,index:i};o.push(c)}if(t.hasAttributes()){const c=t.getAttributeNames();for(const l of c)if(l.endsWith(_)){const d=n[a++],m=t.getAttribute(l);if(m!=="0"){const p=m.split(_);for(let u=0;u<p.length-1;u++){const h={type:S,index:i,attrDynamics:m,name:d};o.push(h)}}else{const p={type:S,index:i,name:d};o.push(p)}t.removeAttribute(l)}}if(z.test(t.tagName)){const c=t.textContent.split(_),l=c.length-1;if(l>0){t.textContent="";for(let d=0;d<l;d++)t.append(c[d],document.createComment("")),g.nextNode(),o.push({type:E,index:++i});t.append(c[l],document.createComment(""))}}}else t.nodeType===8&&t.data===`?${_}`&&o.push({type:E,index:i});i++}return o},R=s=>{const[e,n]=Y(s.parts),o=document.createElement("template");o.innerHTML=e;const t=J(o,s.parts,n);return new q(o,t,D(s))},D=s=>{let e="";const{parts:n,values:o}=s;for(let t=0;t<n.length;t++)e+=n[t],o[t]?.componentName&&(e+=o[t].componentName);return e},Q=(s,e,n)=>{const o=s!==e,t=!!n.attrStructure,i=s?._$wompChildren&&n.startNode.nextSibling!==s.nodes[0];return o||t||i},A=(s,e,n,o,t)=>{const a=e.node;let i=null;const r=s._$wompF,c=r?s.componentName:s;if(a.nodeName!==c.toUpperCase()){const l=a.getAttributeNames();if(r){const p={};for(const h of l){const f=a.getAttribute(h);p[h]=f===""?!0:f}i=new s.class,i._$initialProps=p;const u=a.childNodes;for(;u.length;)i.appendChild(u[0])}else{i=document.createElement(c);for(const p of l)i.setAttribute(p,a.getAttribute(p))}let d=n,m=o[d];for(;m?.node===a;)m.node=i,m=o[++d],m?.name&&m?.name!=="ref"&&(i._$initialProps[m.name]=t[d]);return a.replaceWith(i),i}},b=(s,e,n)=>{const o=[...e];for(let t=0;t<s.length;t++){const a=s[t],i=o[t],r=n[t];if(Q(i,r,a)){if(a.isNode){if(i===!1||i===void 0||i===null){a.clearValue();continue}if(i?._$wompHtml){const m=r?.stringifiedTemplate,p=D(i);if(r===void 0||!(p===m)){const f=R(i).clone(),[k,I]=f;o[t]=new j(p,i.values,f),b(I,i.values,r?.values??r??[]);const V=a.endNode,x=a.startNode;let y=x.nextSibling;for(;y!==V;)y.remove(),y=x.nextSibling;for(y=x;k.childNodes.length;)y.after(k.childNodes[0]),y=y.nextSibling}else{const[h,f]=r.template,k=b(f,i.values,r.values);r.values=k,o[t]=r}continue}const c=i!==Object(i),l=r!==Object(r)&&r!==void 0,d=a.startNode;if(c)l?d.nextSibling?d.nextSibling.textContent=i:d.after(i):(a.clearValue(),d.after(i));else{let m=d.nextSibling,p=0,u=0;if(i._$wompChildren){const h=i.nodes;for(;u<h.length;){(!m||u===0)&&(m=d);const f=h[p];p++,m.after(f),m=m.nextSibling,u++}}else Array.isArray(i)&&(r?.isArrayDependency?o[t]=r.checkUpdates(i):(a.clearValue(),o[t]=new Z(i,a)))}}else if(a.isAttr)if(a.name.startsWith("@"))a.callback=i;else{const l=a.attrStructure;if(l){const d=l.split(_);let m=i;for(let p=0;p<d.length-1;p++)d[p]=`${d[p]}${m}`,t++,m=o[t];t--,a.updateValue(d.join("").trim())}else a.updateValue(i)}else if(a.isTag)if(i._$wompLazy){const l=a.node,d=O(l);d&&(d.addSuspense?d.addSuspense(l):(d.loadingComponents=new Set,d.loadingComponents.add(l)),l.suspense=d),i().then(m=>{const p=A(m,a,t,s,e);d&&d.removeSuspense(l,p)});continue}else A(i,a,t,s,e)}}return o},X=(s,e)=>{const{generatedCSS:n,styles:o}=s.options;let t;const a=`${e.name}__styles`;return window.wompHydrationData?(t=document.createElement("link"),t.rel="stylesheet",t.href=`/${e.name}.css`):(t=document.createElement("style"),n&&(t.classList.add(a),t.textContent=n,e.shadow||document.body.appendChild(t))),class extends HTMLElement{constructor(){super();this._$womp=!0;this.props={};this._$hooks=[];this._$measurePerf=!1;this._$initialProps={};this._$usesContext=!1;this._$hasBeenMoved=!1;this._$layoutEffects=[];this.__updating=!1;this.__oldValues=[];this.__oldPartsStringified="";this.__isInitializing=!0;this.__connected=!1;this.__isInDOM=!1}static{this._$womp=!0}static{this.componentName=e.name}static _$getOrCreateTemplate(c,l){return(!this._$cachedTemplate||l)&&(this._$cachedTemplate=R(c)),this._$cachedTemplate}connectedCallback(){this.__isInDOM=!0,!this.__connected&&this.isConnected&&this.initElement()}disconnectedCallback(){this.__connected&&(this.__isInDOM=!1,Promise.resolve().then(()=>{if(this.__isInDOM)this._$hasBeenMoved=!0,this._$usesContext&&this.requestRender();else{this.onDisconnected();//! For each hook, if the hook is !null && has a cleanupFunction, execute it.
//! This beacuse timers will continue it's execution also after the component has been
//! Disconnected
}}))}onDisconnected(){}initElement(){this.__ROOT=this,this.props={...this.props,...this._$initialProps,styles:o};const c=this.getAttributeNames();for(const p of c)if(!this.props.hasOwnProperty(p)){const u=this.getAttribute(p);this.props[p]=u===""?!0:u}const l=this.__ROOT.childNodes,d=[];for(;l.length;)d.push(l[0]),l[0].remove();const m=new B(d);if(this.props.children=m,e.shadow&&!this.shadowRoot&&(this.__ROOT=this.attachShadow({mode:"open"})),n){const p=t.cloneNode(!0);this.__ROOT.appendChild(p)}this.__render(),this.__isInitializing=!1,this.__connected=!0}__callComponent(){C=this,$=0;const c=s.call(this,this.props);let l=c;return(typeof c=="string"||c instanceof HTMLElement)&&(l=html`${c}`),l}__render(){const c=this.__callComponent();if(c==null){this.remove();return}const l=this.constructor;//! Create a compare htmlTemplates function which will compare each part and return false
//! in the first non-match (better than stringifying the whole templates and compare them).
//! Use it also on __setValues.
const d=D(c),m=d!==this.__oldPartsStringified;if(this.__isInitializing||m){const p=l._$getOrCreateTemplate(c,m),[u,h]=p.clone();this.__dynamics=h;const f=b(this.__dynamics,c.values,this.__oldValues);for(this.__oldValues=f,this.__isInitializing||(this.__ROOT.innerHTML=""),this.__oldPartsStringified=d;u.childNodes.length;)this.__ROOT.appendChild(u.childNodes[0])}else{const p=b(this.__dynamics,c.values,this.__oldValues);this.__oldValues=p}for(;this._$layoutEffects.length;){const p=this._$layoutEffects.pop();p.cleanupFunction=p.callback()}}requestRender(){this.__updating||(this.__updating=!0,Promise.resolve().then(()=>{this.__render(),this.__updating=!1,this._$hasBeenMoved=!1}))}updateProps(c,l){this.props[c]!==l&&(this.props[c]=l,this.__isInitializing||(console.warn(`Updating ${c}`,this.__isInitializing),this.requestRender()))}}};export const useHook=()=>{const n=[C,$];return $++,n},useState=s=>{const[e,n]=useHook();if(!e)return[s,()=>{}];if(!e._$hooks.hasOwnProperty(n)){const t=n;e._$hooks[t]=[s,a=>{let i=a;const r=e._$hooks[t];typeof a=="function"&&(i=a(r[0])),i!==r[0]&&(r[0]=i,e.requestRender())}]}return e._$hooks[n]},useEffect=(s,e=null)=>{const[n,o]=useHook();if(n._$hooks.hasOwnProperty(o)){const t=n._$hooks[o];if(e!==null){for(let a=0;a<e.length;a++)if(t.dependencies[a]!==e[a]){typeof t.cleanupFunction=="function"&&t.cleanupFunction(),Promise.resolve().then(()=>{t.cleanupFunction=s(),t.dependencies=e});break}}else Promise.resolve().then(()=>{t.cleanupFunction=s(),t.dependencies=e})}else{const t={dependencies:e,callback:s,cleanupFunction:null};n._$hooks[o]=t,Promise.resolve().then(()=>{t.cleanupFunction=s()})}},useLayoutEffect=(s,e=null)=>{const[n,o]=useHook();if(n._$hooks.hasOwnProperty(o)){const t=n._$hooks[o];if(e!==null){for(let a=0;a<e.length;a++)if(t.dependencies[a]!==e[a]){typeof t.cleanupFunction=="function"&&t.cleanupFunction(),n._$layoutEffects.push(t),t.dependencies=e;break}}else n._$layoutEffects.push(t)}else{const t={dependencies:e,callback:s,cleanupFunction:null};n._$hooks[o]=t,n._$layoutEffects.push(t)}},useRef=(s=null)=>{const[e,n]=useHook();return e._$hooks.hasOwnProperty(n)||(e._$hooks[n]={current:s,__wcRef:!0}),e._$hooks[n]},useCallback=s=>{const[e,n]=useHook();return e._$hooks.hasOwnProperty(n)||(e._$hooks[n]=s),e._$hooks[n]};const ee=()=>{let s=0;return()=>{const[e,n]=useHook();return e._$hooks.hasOwnProperty(n)||(e._$hooks[n]=`:r${s}:`,s++),e._$hooks[n]}};export const useId=ee(),useMemo=(s,e)=>{const[n,o]=useHook();if(!n._$hooks.hasOwnProperty(o))n._$hooks[o]={value:s(),dependencies:e};else{const a=n._$hooks[o];for(let i=0;i<e.length;i++)if(a.dependencies[i]!==e[i]){a.dependencies=e,a.value=s();break}}return n._$hooks[o].value},useReducer=(s,e)=>{const[n,o]=useHook(),t=o;if(!n._$hooks.hasOwnProperty(t)){const r=[e,c=>{const l=n._$hooks[t][0],d=s(l,c),m=Object.keys(d);for(const u of m)if(d[u]!==l[u]){n.requestRender();break}const p={...l,...d};n._$hooks[o][0]=p}];n._$hooks[o]=r}return n._$hooks[o]},useExposed=s=>{const e=C,n=Object.keys(s);for(const o of n)e[o]=s[o]};const M=(s,e,n)=>{const[o,t]=s;e&&e.addSuspense(o),o._$hooks[t].value=null,n().then(i=>{o.requestRender(),e.removeSuspense(o),o._$hooks[t].value=i}).catch(i=>console.error(i))};export const useAsync=(s,e)=>{const[n,o]=useHook(),t=O(n);if(!n._$hooks.hasOwnProperty(o))n._$hooks[o]={dependencies:e,value:null},M([n,o],t,s);else{const a=n._$hooks[o];let i=!1;for(let r=0;r<e.length;r++)if(a.dependencies[r]!==e[r]){a.dependencies=e,i=!0;break}i&&M([n,o],t,s)}return n._$hooks[o].value};const te=()=>{let s=0;return e=>{const n=`womp-context-provider-${s}`;s++;const o=defineWomp(({children:a})=>{const r=useRef(new Set);return useExposed({subscribers:r}),r.current.forEach(c=>c.requestRender()),html`${a}`},{name:n,cssGeneration:!1});return{name:n,Provider:o,default:e,subscribers:new Set}}};export const createContext=te(),useContext=s=>{const[e,n]=useHook();if(e._$usesContext=!0,!e._$hooks.hasOwnProperty(n)||e._$hasBeenMoved){let t=e;const a=s.name.toUpperCase();for(;t&&t.nodeName!==a&&t!==document.body;)t instanceof ShadowRoot?t=t.host:t=t.parentNode;const i=e._$hooks[n]?.node;if(t&&t!==document.body){t.subscribers.current.add(e);const r=e.onDisconnected;e.onDisconnected=()=>{t.subscribers.current.delete(e),r()}}else i&&i.subscribers.current.delete(e);e._$hooks[n]={node:t}}const o=e._$hooks[n].node;return o?o.props.value:s.default};export function html(s,...e){const n=[],o=s.length-1;if(N)n.push(...e);else for(let t=0;t<o;t++)s[t].endsWith("</")||n.push(e[t]);return{parts:s,values:n,_$wompHtml:!0}}export const wompDefaultOptions={shadow:!1,name:"",cssGeneration:!0},registeredComponents={};export function defineWomp(s,e){s.css||(s.css="");const n={...wompDefaultOptions,...e||{}};if(!n.name){let a=s.name.replace(/.[A-Z]/g,i=>`${i[0]}-${i[1].toLowerCase()}`).toLowerCase();a.includes("-")||(a+="-womp"),n.name=a}s.componentName=n.name,s._$wompF=!0;const[o,t]=K(s,n);if(s.css=o,s.options={generatedCSS:o,styles:t,shadow:n.shadow},!N){const a=X(s,n);s.class=a,customElements.define(n.name,a)}return registeredComponents[n.name]=s,s}export const lazy=s=>{let e=null;async function n(){return e||(e=(await s()).default,e)}return n._$wompLazy=!0,n};const O=s=>{let e=s;for(;e&&e.nodeName!==Suspense.componentName.toUpperCase();)e.parentNode===null&&e.host?e=e.host:e=e?.parentNode;return e};export function Suspense({children:s,fallback:e}){return this.loadingComponents||(this.loadingComponents=useRef(new Set).current),this.addSuspense=n=>{this.loadingComponents.size||this.requestRender(),this.loadingComponents.add(n)},this.removeSuspense=(n,o=null)=>{if(this.loadingComponents.delete(n),o){for(let t=0;t<s.nodes.length;t++)if(s.nodes[t]===n){s.nodes[t]=o;break}}this.loadingComponents.size||this.requestRender()},this.loadingComponents.size?e:html`${s}`}defineWomp(Suspense,{name:"womp-suspense"});//! Test events on custom components
//! Test inputs (value attribute, specifically)
//! in DEV_MODE, handle errors nicely, in PRODUCTION, only console.error
