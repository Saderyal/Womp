{
  "version": 3,
  "sources": ["../ts/womp.ts"],
  "sourcesContent": ["const DEV_MODE = true;\n\n/* \n================================================\nTYPES\n================================================\n*/\n/**\n * The html`` template function result type.\n */\nexport interface RenderHtml {\n\tparts: TemplateStringsArray;\n\tvalues: any[];\n\t_$wompHtml: true;\n}\n\n/**\n * The props of any component.\n */\nexport interface WompProps {\n\t/** The children of the component instance */\n\tchildren?: WompChildren;\n\t/** The styles generated from the CSS provided */\n\tstyles?: { [key: string]: string };\n\t/** In DEV_MODE, will write on the console performance informations. */\n\t['wc-perf']?: boolean;\n\t/** The style of a component to customize in through the style attribute in the DOM. */\n\tstyle?: string | Partial<CSSStyleDeclaration> | object;\n\t/** A potential reference to the element. */\n\tref?: RefHook<any>;\n\t/** The ID of the element */\n\tid?: string;\n\t/** The classes of the element */\n\tclass?: string;\n}\n\n/**\n * The options that a component can have when instantiating.\n * The current available options are:\n * - `name` (string)\n * - `shadow` (boolean)\n * - `cssGeneration` (boolean)\n */\nexport interface WompComponentOptions {\n\t/**\n\t * Default value: `null`.\n\t * The component name. If not defined, the component name will be the name of the function in\n\t * hyphen-case. If the component doesn't have an hyphen, a \"womp\" string will be placed as a\n\t * suffix.\n\t * E.g. TabPanel = tab-panel, Counter = counter-womp\n\t */\n\tname?: string;\n\t/**\n\t * Default value: `false`. If true, the component will be rendered in a shadow DOM.\n\t */\n\tshadow?: boolean;\n\t/**\n\t * Default value: `true`. If true, the CSS of the component will be replaced with a more unique\n\t * CSS. This is done by simply putting the component name as a prefix in every class.\n\t * The generated class names will be put in the [styles] prop of the component.\n\t * This is done to avoid styles collisions.\n\t * E.g. CounterComponent.css = `.button` => .counter-component__button\n\t */\n\tcssGeneration?: boolean;\n}\n\n/**\n * The type of the function to create a Womp Component.\n * It can have a custom `css` property, corresponding to the specific styles of the component.\n */\nexport interface WompComponent<Props extends WompProps = WompProps> {\n\t/** The props of the component */\n\t(props: Props): RenderHtml;\n\t/**\n\t * The specific styles of the component.\n\t */\n\tcss?: string;\n\t/** The component name, elaborated in the defineWomp function */\n\tcomponentName?: string;\n\t/** Identifies the component */\n\t_$wompF?: true;\n\t/** The generated class of the component */\n\tclass?: WompElementClass<Props>;\n}\n\n/**\n * The type of a Womp component Instance.\n * The public accessible properties are:\n * - `hooks`: Hook[]\n * - `props`: WompProps\n * - `initialProps`: WompProps\n * - `measurePerf`: boolean\n * - `_$womp`: true\n *\n * The public accessible methods are:\n * - `requestRender()`\n * - `onDisconnected()`\n * - `updateProps(prop, newValue)`\n */\nexport type WompElement<Props extends WompProps = WompProps, E = {}> = HTMLElement &\n\tE & {\n\t\t/**\n\t\t * The props of the component, that are then passed in the function.\n\t\t */\n\t\tprops: Props;\n\n\t\t/**\n\t\t * The hooks of the component. They are accessed by the position in the array.\n\t\t */\n\t\t_$hooks: Hook[];\n\n\t\t/**\n\t\t * The initial props of a component. This property is only used internally when\n\t\t * using a dyanmic tag.\n\t\t */\n\t\t_$initialProps: WompProps;\n\n\t\t/**\n\t\t * True if the component wants to log the rendering time in the console. Only\n\t\t * available in DEV_MODE.\n\t\t * This property is set to true only when a component has the attribute or\n\t\t * initial prop [wc-perf].\n\t\t */\n\t\t_$measurePerf: boolean;\n\n\t\t/**\n\t\t * True if the component uses a context.\n\t\t */\n\t\t_$usesContext: boolean;\n\n\t\t/**\n\t\t * True if the component has recently been moved. Used to know if a component should search\n\t\t * again for parent contexts.\n\t\t */\n\t\t_$hasBeenMoved: boolean;\n\n\t\t/**\n\t\t * Requests a render to the component.\n\t\t * @returns void\n\t\t */\n\t\trequestRender: () => void;\n\n\t\t/**\n\t\t * A callback that gets executed whenever the component id disconnected\n\t\t * **definitely** from the DOM. This callback is not called when the\n\t\t * component is just moved from one node to another.\n\t\t * @returns void\n\t\t */\n\t\tonDisconnected: () => void;\n\n\t\t/**\n\t\t * Update a [prop] of the component with the [newValue]. It automatically\n\t\t * re-render the component if the old value and the new value differs.\n\t\t * @param prop The prop name to update\n\t\t * @param newValue The new value to put in the prop\n\t\t * @returns void\n\t\t */\n\t\tupdateProps: (prop: string, newValue: any) => void;\n\n\t\t/**\n\t\t * An identifier to rapidly know if a node is a womp component.\n\t\t */\n\t\t_$womp: true;\n\t};\n\n/** The possible hooks that a component can have. */\ntype Hook =\n\t| StateHook<any>\n\t| EffectHook\n\t| RefHook<any>\n\t| CallbackHook\n\t| IdHook\n\t| MemoHook\n\t| ReducerHook<any>\n\t| ContextHook<any>;\n\n/** The hook generated by the useState function */\ntype StateHook<S> = [S, (newValue: S) => void];\n\n/** The hook generated by the useEffect and useLayoutEffect functions */\ninterface EffectHook {\n\tdependencies: any;\n\tcallback: VoidFunction | (() => VoidFunction);\n\tcleanupFunction: VoidFunction | void;\n}\n\n/** The hook generated by the useRef function */\ninterface RefHook<V> {\n\tcurrent: V;\n\t__wcRef: true;\n}\n\n/** The hook generated by the useCallback function */\ninterface CallbackHook {\n\t(...args: any[]): any;\n}\n\n/** The hook generated by the useId function */\ntype IdHook = string;\n\n/** The hook generated by the useMemo function */\ninterface MemoHook {\n\tdependencies: any[];\n\tvalue: any;\n}\n\ninterface ReducerAction {\n\ttype: string;\n\t[key: string]: any;\n}\n/** The hook generated by the useState function */\ntype ReducerHook<State> = [State, (state: any, action: ReducerAction) => void];\n\n/** The props type of a ContextProvider */\ninterface ContextProviderProps extends WompProps {\n\tvalue: any;\n}\n/** The exposed values of a ContextProvider */\ninterface ContextProviderExposed {\n\tsubscribers: RefHook<Set<WompElement>>;\n}\n/** The type of a ContextProvier instance */\ntype ContextInstance = WompElement<ContextProviderProps, ContextProviderExposed>;\n\n/** The hook generated by the useContext hook */\ninterface ContextHook<V = any> {\n\tnode: ContextInstance;\n\tvalue: V;\n}\n\n/**\n * The type of the class generated by the womp() function.\n */\ninterface WompElementClass<Props extends WompProps, E = {}> {\n\t/** The constructor */\n\tnew (): WompElement<Props, E>;\n\t/** The cached template data. This is generated only the first time a component renders. */\n\t_$cachedTemplate: CachedTemplate;\n\t/** This function will get or create a new CachedTemplate instance. */\n\t_$getOrCreateTemplate(parts: TemplateStringsArray): CachedTemplate;\n}\n\n/**\n * Each CachedTemplate will generate an array of Dependencies that are metadata to efficientluy\n * update the elements.\n */\ninterface Dependency {\n\t/** The type of the dependency (ATTRIBUTE, NODE, TAG) */\n\ttype: number;\n\t/** The index of the element when walked with the treeWalker */\n\tindex: number;\n\t/** This option is valorized if the type is ATTRIBUTE */\n\tname?: string;\n\t/**\n\t * This option is valorized if the type is ATTRIBUTE and it's a composed attribute.\n\t * (e.g. class=\"button ${'button-primary'}\")\n\t */\n\tattrDynamics?: string;\n}\n\n/**\n * The possible dynamic values: DynamicNode | DynamicAttribute | DynamicTag.\n */\ntype Dynamics = DynamicNode | DynamicAttribute | DynamicTag;\n\n/* \n================================================\nVARIABLES\n================================================\n*/\n/**\n * The current rendering component instance. This is used when creating hooks.\n * This variable is exposed only in the `useHook` hook.\n */\nlet currentRenderingComponent: WompElement = null;\n/**\n * The current hook index in a component. This is used when creating hooks.\n * This variable is exposed only in the `useHook` hook.\n */\nlet currentHookIndex: number = 0;\n\nconst WC_MARKER = '$wc$';\nconst DYNAMIC_TAG_MARKER = 'wc-wc';\nconst isDynamicTagRegex = /<\\/?$/g;\nconst isAttrRegex = /\\s+([^\\s]*?)=\"?$/g;\nconst selfClosingRegex = /(<([a-x]*?-[a-z]*).*?)\\/>/g;\nconst isInsideTextTag = /<(?<tag>script|style|textarea|title])(?!.*?<\\/\\k<tag>)/gi;\nconst onlyTextChildrenElementsRegex = /^(?:script|style|textarea|title)$/i;\n\nconst NODE = 0; // Is a NODE Dependency.\nconst ATTR = 1; // Is an ATTRIBUTE Dependency.\nconst TAG = 2; // Is a TAG Dependency.c\n\nconst IS_SERVER = global.document === undefined;\n\nconst doc = IS_SERVER ? ({ createTreeWalker() {} } as unknown as Document) : document;\n\nconst treeWalker = doc.createTreeWalker(\n\tdoc,\n\t129 // NodeFilter.SHOW_{ELEMENT|COMMENT}\n);\n\n/* \n================================================\nCLASSES\n================================================\n*/\n/**\n * The CachedTemplate class is used to efficiently render components. The template HTML element is\n * stored here and only cloned when a new component is instantiated.\n */\nclass CachedTemplate {\n\t/**\n\t * The HTML Template element that has all the structure and comments built in to identify dynamic\n\t * elements.\n\t */\n\tpublic template: HTMLTemplateElement;\n\t/**\n\t * The list of metadata dependencies used to know which node/attribute should listen to updates\n\t * when a variable changes.\n\t */\n\tpublic dependencies: Dependency[];\n\n\t/**\n\t * Create a new CachedTemplate instance.\n\t * @param template The HTML Template already elaborated to handle the dynamic parts.\n\t * @param dependencies The metadata dependencies for the template.\n\t */\n\tconstructor(template: HTMLTemplateElement, dependencies: Dependency[]) {\n\t\tthis.template = template;\n\t\tthis.dependencies = dependencies;\n\t}\n\n\t/**\n\t * This function will clone the template content and build the dynamcis metadata - an array\n\t * containing all the information to efficiently put values in the DOM, without checking if each\n\t * node is equal to a virtual one. The DOM update is not done through this function, but thanks to\n\t * the `__setValues` function.\n\t * @returns An array containing 2 values: The DOM fragment cloned from the content of the\n\t * template, and the dynamics metadata.\n\t */\n\tpublic clone(): [DocumentFragment, Dynamics[]] {\n\t\tconst content = this.template.content;\n\t\tconst dependencies = this.dependencies;\n\t\tconst fragment = document.importNode(content, true);\n\t\ttreeWalker.currentNode = fragment;\n\t\tlet node = treeWalker.nextNode();\n\t\tlet nodeIndex = 0;\n\t\tlet dynamicIndex = 0;\n\t\tlet templateDependency = dependencies[0];\n\t\tconst dynamics = [];\n\t\twhile (templateDependency !== undefined) {\n\t\t\tif (nodeIndex === templateDependency.index) {\n\t\t\t\tlet dynamic: Dynamics;\n\t\t\t\tconst type = templateDependency.type;\n\t\t\t\tif (type === NODE) {\n\t\t\t\t\tdynamic = new DynamicNode(node as HTMLElement, node.nextSibling);\n\t\t\t\t} else if (type === ATTR) {\n\t\t\t\t\tdynamic = new DynamicAttribute(node as HTMLElement, templateDependency);\n\t\t\t\t} else if (type === TAG) {\n\t\t\t\t\tdynamic = new DynamicTag(node as HTMLElement);\n\t\t\t\t}\n\t\t\t\tdynamics.push(dynamic);\n\t\t\t\ttemplateDependency = dependencies[++dynamicIndex];\n\t\t\t}\n\t\t\tif (nodeIndex !== templateDependency?.index) {\n\t\t\t\tnode = treeWalker.nextNode()!;\n\t\t\t\tnodeIndex++;\n\t\t\t}\n\t\t}\n\t\ttreeWalker.currentNode = document;\n\t\treturn [fragment, dynamics];\n\t}\n}\n\n/**\n * This function is used to store dynamic parts of one component that used the value returned by the\n * `html` function. It allows to create kinda the same process of caching used by every component,\n * so a [dynamics] array is build and used to perform updated on the html result.\n */\nclass HtmlProcessedValue {\n\t/**\n\t * The stringified template is the result of the `html` function without the dynamic parts. This\n\t * property is used to compare 2 different html results.\n\t */\n\tpublic stringifiedTemplate: string;\n\t/** The last values that the html function returned. */\n\tpublic values: any[];\n\t/** The Cached template data returned by the `clone` function. */\n\tpublic template: [DocumentFragment, Dynamics[]];\n\n\tconstructor(\n\t\tstringifiedTemplate: string,\n\t\tvalues: any[],\n\t\ttemplate: [DocumentFragment, Dynamics[]]\n\t) {\n\t\tthis.stringifiedTemplate = stringifiedTemplate;\n\t\tthis.values = values;\n\t\tthis.template = template;\n\t}\n}\n\n/**\n * Contains the data about a Dynamic node.\n */\nclass DynamicNode {\n\t/**\n\t * The start node marks the point on where dynamic nodes must be put after.\n\t * It's a static HTML element. Values between the startNode and endNode are known to be dynamic.\n\t */\n\tpublic startNode: ChildNode;\n\t/**\n\t * The end node marks the point on where dynamic nodes must be put before.\n\t * It's a static HTML element. Values between the startNode and endNode are known to be dynamic.\n\t */\n\tpublic endNode: ChildNode | null;\n\n\tpublic isNode: true = true; // For faster access\n\tpublic isAttr: false = false; // For faster access\n\tpublic isTag: false = false; // For faster access\n\n\t/**\n\t * Creates a new DynamicNode instance.\n\t * @param startNode The start node.\n\t * @param endNode The end node.\n\t */\n\tconstructor(startNode: ChildNode, endNode: ChildNode | null) {\n\t\tthis.startNode = startNode;\n\t\tthis.endNode = endNode;\n\t}\n\n\t/**\n\t * Removes all the nodes between the start and the end nodes.\n\t */\n\tpublic clearValue() {\n\t\tlet currentNode = this.startNode.nextSibling;\n\t\twhile (currentNode !== this.endNode) {\n\t\t\tcurrentNode.remove();\n\t\t\tcurrentNode = this.startNode.nextSibling;\n\t\t}\n\t}\n\n\t/**\n\t * First removes all the nodes between the start and the end nodes, then it also removes the\n\t * start node and the end node.\n\t */\n\tpublic dispose() {\n\t\tthis.clearValue();\n\t\tthis.startNode.remove();\n\t\tthis.endNode.remove();\n\t}\n}\n\n/**\n * Contains the data about a dynamic attribute.\n */\nclass DynamicAttribute {\n\t/** The node that owns the dynamic attribute */\n\tpublic node: HTMLElement;\n\t/** The name of the dynamic attribute. */\n\tpublic name: string;\n\t/**\n\t * If an attribute has only some dynamic parts, this property will contain the whole attribute\n\t * structure. E.g. class=\"button ${'hidden'}\".\n\t */\n\tpublic attrStructure: string;\n\n\tpublic isNode: false = false; // For faster access\n\tpublic isAttr: true = true; // For faster access\n\tpublic isTag: false = false; // For faster access\n\n\t/** The callback to execute when an event is fired. */\n\tprivate __callback: (event: Event) => void;\n\t/** True if an event has already been initialized. */\n\tprivate __eventInitialized = false;\n\n\t/**\n\t * Creates a new DynamicAttribute instance.\n\t * @param node The node that owns the attribute.\n\t * @param dependency The dependency metadata.\n\t */\n\tconstructor(node: HTMLElement, dependency: Dependency) {\n\t\tthis.node = node;\n\t\tthis.name = dependency.name;\n\t\tthis.attrStructure = dependency.attrDynamics;\n\t}\n\n\t/**\n\t * Update an attribute value.\n\t * @param newValue The new value of the attribute\n\t */\n\tpublic updateValue(newValue: any) {\n\t\tif (this.name === 'ref' && newValue.__wcRef) {\n\t\t\tnewValue.current = this.node;\n\t\t\tif ((this.node as WompElement)._$womp) {\n\t\t\t\tconst oldDisconnectedCallback = (this.node as WompElement).onDisconnected;\n\t\t\t\t(this.node as WompElement).onDisconnected = () => {\n\t\t\t\t\tnewValue.current = null;\n\t\t\t\t\toldDisconnectedCallback();\n\t\t\t\t};\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\t\tif (DEV_MODE && this.name === 'wc-perf') {\n\t\t\t(this.node as WompElement)._$measurePerf = true;\n\t\t}\n\t\tconst isWompElement = (this.node as WompElement)._$womp;\n\t\tif (isWompElement) (this.node as WompElement).updateProps(this.name, newValue);\n\t\tconst isPrimitive = newValue !== Object(newValue);\n\t\tif (newValue === false) this.node.removeAttribute(this.name);\n\t\telse if (isPrimitive && !this.name.match(/[A-Z]/)) this.node.setAttribute(this.name, newValue);\n\t\telse if (this.name === 'style') {\n\t\t\tlet styleString = '';\n\t\t\tconst styles = Object.keys(newValue);\n\t\t\tfor (const key of styles) {\n\t\t\t\tlet styleValue = newValue[key];\n\t\t\t\tlet styleKey = key.replace(/[A-Z]/g, (letter) => '-' + letter.toLowerCase());\n\t\t\t\tif (typeof styleValue === 'number') styleValue = `${styleValue}px`;\n\t\t\t\tstyleString += `${styleKey}:${styleValue};`;\n\t\t\t}\n\t\t\tthis.node.setAttribute(this.name, styleString);\n\t\t}\n\t\tif (this.name === 'title' && isWompElement) this.node.removeAttribute(this.name);\n\t}\n\n\t/**\n\t * Set the callback function to be executed when an event is fired. If the event has not been\n\t * initialized, the event listener will be added.\n\t */\n\tset callback(callback: (event: Event) => void) {\n\t\tif (!this.__eventInitialized) {\n\t\t\tconst eventName = this.name.substring(1);\n\t\t\tthis.node.addEventListener(eventName, this.__listener.bind(this));\n\t\t\tthis.__eventInitialized = true;\n\t\t}\n\t\tthis.__callback = callback;\n\t}\n\n\t/**\n\t * The listener that will execute the __callback function (if defined).\n\t * @param event The event object\n\t */\n\tprivate __listener(event: Event) {\n\t\tif (this.__callback) this.__callback(event);\n\t}\n}\n\n/**\n * Contains the data about a dynamic tag name.\n */\nclass DynamicTag {\n\t/** The node that has the dynamic tag. */\n\tpublic node: ChildNode;\n\n\tpublic isNode: false = false; // For faster access\n\tpublic isAttr: false = false; // For faster access\n\tpublic isTag: true = true; // For faster access\n\n\t/**\n\t * Creates a new DynamicTag instance.\n\t * @param node The node instance.\n\t */\n\tconstructor(node: ChildNode) {\n\t\tthis.node = node;\n\t}\n}\n\n/**\n * Holds the children of a component. They are stored in an array of nodes instead of an NodeList or\n * HTMLCollection, so that they are not lost and reusable when removed from the DOM.\n */\nclass WompChildren {\n\tpublic nodes: Node[];\n\n\tpublic _$wompChildren: true = true;\n\n\tconstructor(nodes: Node[]) {\n\t\tthis.nodes = nodes;\n\t}\n}\n\n/**\n * Hold the informations to efficiently update a dynamic value that is an array.\n */\nclass WompArrayDependency {\n\t/** A list of dynamic nodes, used to know where each item of the array begins and ends. */\n\tpublic dynamics: DynamicNode[];\n\n\tpublic isArrayDependency: true = true; // For faster access\n\n\t/** The array containing the old values, for comparisons. */\n\tprivate __oldValues: any[];\n\t/** The parent dynamic node dependency. */\n\tprivate __parentDependency: DynamicNode;\n\n\t/**\n\t * Creates a new WompArrayDependency instance.\n\t * @param values The array of values to put in the DOM\n\t * @param dependency The dynamic node dependency on which the array should be rendered.\n\t */\n\tconstructor(values: any[], dependency: DynamicNode) {\n\t\tthis.dynamics = [];\n\t\tthis.__parentDependency = dependency;\n\t\tthis.addDependenciesFrom(dependency.startNode as HTMLElement, values.length);\n\t\tthis.__oldValues = __setValues(this.dynamics, values, []);\n\t}\n\n\t/**\n\t * This function will add markers (HTML comments) and generate dynamic nodes dependecies used to\n\t * efficiently udpate the values inside of the array.\n\t * @param startNode The start node on which insert the new \"single-item\" dependencies.\n\t * @param toAdd The number of dependencies to generate.\n\t */\n\tprivate addDependenciesFrom(startNode: HTMLElement, toAdd: number) {\n\t\tlet currentNode = startNode;\n\t\tlet toAddNumber = toAdd;\n\t\twhile (toAddNumber) {\n\t\t\tconst startComment = document.createComment(`?START`);\n\t\t\tconst endComment = document.createComment(`?END`);\n\t\t\tcurrentNode.after(startComment);\n\t\t\tstartComment.after(endComment);\n\t\t\tconst dependency = new DynamicNode(startComment, endComment);\n\t\t\tcurrentNode = endComment as unknown as HTMLElement;\n\t\t\tthis.dynamics.push(dependency);\n\t\t\ttoAddNumber--;\n\t\t}\n\t}\n\n\t/**\n\t * Check if there are dependencies to add/remove, and then set the new values to the old nodes.\n\t * Setting the new values will start an eventual recursive check for eventual nested arrays.\n\t * @param newValues The new values to check with the old ones fot updates.\n\t * @returns This instance.\n\t */\n\tpublic checkUpdates(newValues: any[]) {\n\t\tlet diff = newValues.length - this.__oldValues.length;\n\t\tif (diff > 0) {\n\t\t\tlet startNode = this.dynamics[this.dynamics.length - 1]?.endNode;\n\t\t\tif (!startNode) startNode = this.__parentDependency.startNode;\n\t\t\tthis.addDependenciesFrom(startNode as HTMLElement, diff);\n\t\t} else if (diff < 0) {\n\t\t\twhile (diff) {\n\t\t\t\tconst toClean = this.dynamics.pop();\n\t\t\t\ttoClean.dispose();\n\t\t\t\tdiff++;\n\t\t\t}\n\t\t}\n\t\tthis.__oldValues = __setValues(this.dynamics, newValues, this.__oldValues);\n\t\treturn this;\n\t}\n}\n\n/* \n================================================\nSUPPORT FUNCTIONS\n================================================\n*/\n\n/**\n * Generates the static styles of a component. If the `cssGeneration` option in the component is\n * false, the generation will be skipped and the css will be taken as it is.\n * If the css contains an \":host\" selector, it'll be replaced or kept based on if the shadow option\n * is true, otherwise, a default \"display: block;\" style will be added in the component.\n * @returns an array of 2 values: the first is the generated CSS string, the second is an object\n * having as keys the original class names, and as the value the replaced class names.\n */\nconst __generateSpecifcStyles = (\n\tcomponent: WompComponent,\n\toptions: WompComponentOptions\n): [string, { [className: string]: string }] => {\n\tconst { css } = component;\n\tconst { shadow, name, cssGeneration } = options;\n\tconst componentName = name;\n\tconst classes: { [key: string]: string } = {};\n\tlet generatedCss = css;\n\tif (DEV_MODE) {\n\t\tif (!shadow && !cssGeneration && !name.startsWith('womp-context-provider'))\n\t\t\tconsole.warn(\n\t\t\t\t`The component ${name} is not an isolated component (shadow=false) and has the ` +\n\t\t\t\t\t`cssGeneration option set to false.\\nThis can lead to unexpected behaviors, because ` +\n\t\t\t\t\t`this component can alter other components' styles.`\n\t\t\t);\n\t}\n\tif (cssGeneration) {\n\t\tlet completeCss = css;\n\t\tif (!css.includes(':host'))\n\t\t\tcompleteCss = `${shadow ? ':host' : componentName} {display:block;} ${css}`;\n\t\tif (DEV_MODE) {\n\t\t\tconst invalidSelectors: string[] = [];\n\t\t\t// It's appropriate that at least one class is present in each selector\n\t\t\t[...completeCss.matchAll(/.*?}([\\s\\S]*?){/gm)].forEach((selector) => {\n\t\t\t\tconst cssSelector = selector[1].trim();\n\t\t\t\tif (!cssSelector.includes('.')) invalidSelectors.push(cssSelector);\n\t\t\t});\n\t\t\tinvalidSelectors.forEach((selector) => {\n\t\t\t\tconsole.warn(\n\t\t\t\t\t`The CSS selector \"${selector} {...}\" in the component \"${componentName}\" is not enough` +\n\t\t\t\t\t\t` specific: include at least one class.`\n\t\t\t\t);\n\t\t\t});\n\t\t}\n\t\tif (!shadow) generatedCss = generatedCss.replace(/:host/g, componentName);\n\t\tgeneratedCss = generatedCss.replace(/\\.(?!\\d)(.*?)[\\s|{|,|+|~|>]/gm, (_, className) => {\n\t\t\tconst uniqueClassName = `${componentName}__${className}`;\n\t\t\tclasses[className] = uniqueClassName;\n\t\t\treturn `.${uniqueClassName} `;\n\t\t});\n\t}\n\treturn [generatedCss, classes];\n};\n\n/**\n * This function will create the valid HTML string to put in a template, used then to create the DOM\n * of a component and obtain the dynamic metadata.\n * @param parts The static parts of the `html` function.\n * @returns An array having 2 values: the generated HTML string, and a list of attribute names that\n * are known to be dynamic.\n */\nconst __createHtml = (parts: TemplateStringsArray): [string, string[]] => {\n\tlet html = '';\n\tconst attributes = [];\n\tconst length = parts.length - 1;\n\tlet attrDelimiter = '';\n\tlet textTagName = '';\n\tfor (let i = 0; i < length; i++) {\n\t\tlet part = parts[i];\n\t\t// End of values inside an attribute\n\t\tif (attrDelimiter && part.includes(attrDelimiter)) attrDelimiter = '';\n\t\t// End of values inside a text node (script, textarea, title, style)\n\t\tif (textTagName && new RegExp(`<\\/${textTagName}>`)) textTagName = '';\n\t\tif (attrDelimiter || textTagName) {\n\t\t\t// We are inside an attribute\n\t\t\thtml += part + WC_MARKER;\n\t\t} else {\n\t\t\t// If the Regex is global, it will start from the index past the end of the last match.\n\t\t\tisAttrRegex.lastIndex = 0;\n\t\t\tconst isAttr = isAttrRegex.exec(part);\n\t\t\tif (isAttr) {\n\t\t\t\tconst [match, attrName] = isAttr;\n\t\t\t\tconst beforeLastChar = match[match.length - 1];\n\t\t\t\tattrDelimiter = beforeLastChar === '\"' || beforeLastChar === \"'\" ? beforeLastChar : '';\n\t\t\t\tpart = part.substring(0, part.length - attrDelimiter.length - 1);\n\t\t\t\tlet toAdd = `${part}${WC_MARKER}=`;\n\t\t\t\tif (attrDelimiter) toAdd += `${attrDelimiter}${WC_MARKER}`;\n\t\t\t\telse toAdd += '\"0\"';\n\t\t\t\thtml += toAdd;\n\t\t\t\tattributes.push(attrName);\n\t\t\t} else {\n\t\t\t\tif (part.match(isDynamicTagRegex)) {\n\t\t\t\t\thtml += part + DYNAMIC_TAG_MARKER;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tisInsideTextTag.lastIndex = 0;\n\t\t\t\tconst insideTextTag = isInsideTextTag.exec(part);\n\t\t\t\tif (insideTextTag) {\n\t\t\t\t\ttextTagName = insideTextTag[1];\n\t\t\t\t\thtml += part + WC_MARKER;\n\t\t\t\t} else {\n\t\t\t\t\t// It's a child node\n\t\t\t\t\thtml += part + `<?${WC_MARKER}>`;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\thtml += parts[parts.length - 1];\n\thtml = html.replace(selfClosingRegex, '$1></$2>');\n\treturn [html, attributes];\n};\n\n/**\n * Based on a template content, this function will extract the dynamic dependecies, and build the\n * metadata used to efficiently update the nodes during re-render.\n * @param template An HTML Template element\n * @param parts The parts returned by the `html` function\n * @param attributes The dynamic attribute names obtained by the `__createHtml` function.\n * @returns The list of elaborated dependencies\n */\nconst __createDependencies = (\n\ttemplate: HTMLTemplateElement,\n\tparts: TemplateStringsArray,\n\tattributes: string[]\n) => {\n\tconst dependencies = [];\n\ttreeWalker.currentNode = template.content;\n\tlet node: Element;\n\tlet dependencyIndex = 0;\n\tlet nodeIndex = 0;\n\tconst partsLength = parts.length;\n\twhile (((node as Node) = treeWalker.nextNode()) !== null && dependencies.length < partsLength) {\n\t\t// Is a \"normal\" node\n\t\tif (node.nodeType === 1) {\n\t\t\tif (node.nodeName === DYNAMIC_TAG_MARKER.toUpperCase()) {\n\t\t\t\tconst dependency: Dependency = {\n\t\t\t\t\ttype: TAG,\n\t\t\t\t\tindex: nodeIndex,\n\t\t\t\t};\n\t\t\t\tdependencies.push(dependency);\n\t\t\t}\n\t\t\tif (node.hasAttributes()) {\n\t\t\t\tconst attributeNames = node.getAttributeNames();\n\t\t\t\tfor (const attrName of attributeNames) {\n\t\t\t\t\tif (attrName.endsWith(WC_MARKER)) {\n\t\t\t\t\t\tconst realName = attributes[dependencyIndex++];\n\t\t\t\t\t\tconst attrValue = node.getAttribute(attrName);\n\t\t\t\t\t\tif (attrValue !== '0') {\n\t\t\t\t\t\t\tconst dynamicParts = attrValue.split(WC_MARKER);\n\t\t\t\t\t\t\tfor (let i = 0; i < dynamicParts.length - 1; i++) {\n\t\t\t\t\t\t\t\tconst dependency: Dependency = {\n\t\t\t\t\t\t\t\t\ttype: ATTR,\n\t\t\t\t\t\t\t\t\tindex: nodeIndex,\n\t\t\t\t\t\t\t\t\tattrDynamics: attrValue,\n\t\t\t\t\t\t\t\t\tname: realName,\n\t\t\t\t\t\t\t\t};\n\t\t\t\t\t\t\t\tdependencies.push(dependency);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tconst dependency: Dependency = {\n\t\t\t\t\t\t\t\ttype: ATTR,\n\t\t\t\t\t\t\t\tindex: nodeIndex,\n\t\t\t\t\t\t\t\tname: realName,\n\t\t\t\t\t\t\t};\n\t\t\t\t\t\t\tdependencies.push(dependency);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tnode.removeAttribute(attrName);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t// A text node should be created for each dynamic part inside of\n\t\t\t// nodes that only have text nodes inside (script, style, textarea, title).\n\t\t\tif (onlyTextChildrenElementsRegex.test(node.tagName)) {\n\t\t\t\tconst strings = node.textContent!.split(WC_MARKER);\n\t\t\t\tconst lastIndex = strings.length - 1;\n\t\t\t\tif (lastIndex > 0) {\n\t\t\t\t\tnode.textContent = '';\n\t\t\t\t\tfor (let i = 0; i < lastIndex; i++) {\n\t\t\t\t\t\tnode.append(strings[i], document.createComment(''));\n\t\t\t\t\t\t// Walk past the marker node we just added\n\t\t\t\t\t\ttreeWalker.nextNode();\n\t\t\t\t\t\tdependencies.push({ type: NODE, index: ++nodeIndex });\n\t\t\t\t\t}\n\t\t\t\t\t// It's not necessary to adjust nodeIndex here\n\t\t\t\t\tnode.append(strings[lastIndex], document.createComment(''));\n\t\t\t\t}\n\t\t\t}\n\t\t} else if (node.nodeType === 8) {\n\t\t\t// Is a comment\n\t\t\tconst data = (node as unknown as Comment).data;\n\t\t\tif (data === `?${WC_MARKER}`) dependencies.push({ type: NODE, index: nodeIndex });\n\t\t}\n\t\tnodeIndex++;\n\t}\n\treturn dependencies;\n};\n\n/**\n * Create a new CachedTemplate, by first obtaining the html content string, and then creating the\n * dependencies. The newly created template will be then used by components of the same type.\n * @param parts The parts returned by the `html` function.\n * @returns a new instance of CachedTemplate\n */\nconst __createTemplate = (parts: TemplateStringsArray) => {\n\tconst [dom, attributes] = __createHtml(parts);\n\tconst template = document.createElement('template');\n\ttemplate.innerHTML = dom;\n\tconst dependencies = __createDependencies(template, parts, attributes);\n\treturn new CachedTemplate(template, dependencies);\n};\n\n/**\n * This function will \"stringify\" the result of the `html` function, by simply joining all the parts\n * of the template. The stringified version is used to compare 2 html results. If the 2 strings are\n * equal, the 2 templates are also considered to be equal (dynamic values excluded).\n * @param render The whole result of the `html` function\n * @returns The string representation of the the template.\n */\nconst __getRenderHtmlString = (render: RenderHtml) => {\n\tlet value = '';\n\tconst { parts, values } = render;\n\tfor (let i = 0; i < parts.length; i++) {\n\t\tvalue += parts[i];\n\t\tif (values[i]?.componentName) value += values[i].componentName;\n\t}\n\treturn value;\n};\n\n/**\n * Compare the old value with the new value, and returns true if they differs.\n * @param currentValue The current value\n * @param oldValue The old value\n * @param dependency The dependency that includes the value\n * @returns True if the dependency should be updated\n */\nconst __shouldUpdate = (currentValue: any, oldValue: any, dependency: Dynamics) => {\n\tconst valuesDiffers = currentValue !== oldValue;\n\tconst isComposedAttribute = !!(dependency as DynamicAttribute).attrStructure;\n\tconst isWompChildren = currentValue?._$wompChildren;\n\tconst childrenNeedUpdate =\n\t\tisWompChildren && (dependency as DynamicNode).startNode.nextSibling !== currentValue.nodes[0];\n\treturn valuesDiffers || isComposedAttribute || childrenNeedUpdate;\n};\n\n/**\n * This function will compare the values of the previous render with the current one, and update the\n * DOM accordingly.\n * This function alters the original [dynamics] array: **it's not pure**.\n * @param dynamics The array of dynamic dependencies\n * @param values The new values of the render\n * @param oldValues The old values used in the previous render\n * @returns A modified version of the new values\n */\nconst __setValues = (dynamics: Dynamics[], values: any[], oldValues: any[]) => {\n\tconst newValues = [...values];\n\tfor (let i = 0; i < dynamics.length; i++) {\n\t\tconst currentDependency = dynamics[i];\n\t\tconst currentValue = newValues[i];\n\t\tconst oldValue = oldValues[i];\n\t\tif (!__shouldUpdate(currentValue, oldValue, currentDependency))\n\t\t\t// Skip update: values are the same\n\t\t\tcontinue;\n\t\tif (currentDependency.isNode) {\n\t\t\t// Falsy values are cleared from the DOM\n\t\t\tif (currentValue === false) {\n\t\t\t\tcurrentDependency.clearValue();\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (currentValue?._$wompHtml) {\n\t\t\t\t// handle template elements\n\t\t\t\tconst oldStringified = oldValue?.stringifiedTemplate;\n\t\t\t\tconst newTemplate = __getRenderHtmlString(currentValue);\n\t\t\t\tconst sameString = newTemplate === oldStringified;\n\t\t\t\tif (oldValue === undefined || !sameString) {\n\t\t\t\t\tconst cachedTemplate = __createTemplate(currentValue.parts);\n\t\t\t\t\tconst template = cachedTemplate.clone();\n\t\t\t\t\tconst [fragment, dynamics] = template;\n\t\t\t\t\tnewValues[i] = new HtmlProcessedValue(newTemplate, currentValue.values, template);\n\t\t\t\t\t__setValues(dynamics, currentValue.values, oldValue?.values ?? oldValue ?? []);\n\t\t\t\t\tconst endNode = (currentDependency as DynamicNode).endNode;\n\t\t\t\t\tconst startNode = (currentDependency as DynamicNode).startNode;\n\t\t\t\t\tlet currentNode = startNode.nextSibling;\n\t\t\t\t\twhile (currentNode !== endNode) {\n\t\t\t\t\t\tcurrentNode.remove();\n\t\t\t\t\t\tcurrentNode = startNode.nextSibling;\n\t\t\t\t\t}\n\t\t\t\t\tcurrentNode = startNode;\n\t\t\t\t\twhile (fragment.childNodes.length) {\n\t\t\t\t\t\tcurrentNode.after(fragment.childNodes[0]);\n\t\t\t\t\t\tcurrentNode = currentNode.nextSibling;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tconst [_, dynamics] = (oldValue as HtmlProcessedValue).template;\n\t\t\t\t\tconst processedValues = __setValues(\n\t\t\t\t\t\tdynamics,\n\t\t\t\t\t\tcurrentValue.values,\n\t\t\t\t\t\t(oldValue as HtmlProcessedValue).values\n\t\t\t\t\t);\n\t\t\t\t\t(oldValue as HtmlProcessedValue).values = processedValues;\n\t\t\t\t\tnewValues[i] = oldValue;\n\t\t\t\t}\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t// It's not necessary to check every single node: if a dependency updates,\n\t\t\t// it'll be automatically updated. It's only necessary to update the\n\t\t\t// textContent of primitive values.\n\t\t\tconst isPrimitive = currentValue !== Object(currentValue);\n\t\t\tconst oldIsPrimitive = oldValue !== Object(oldValue) && oldValue !== undefined;\n\t\t\tconst startNode = currentDependency.startNode;\n\t\t\tif (isPrimitive) {\n\t\t\t\tif (oldIsPrimitive) {\n\t\t\t\t\t// At this point there's already a content in the node\n\t\t\t\t\tif (startNode.nextSibling) startNode.nextSibling.textContent = currentValue;\n\t\t\t\t\telse startNode.after(currentValue);\n\t\t\t\t} else {\n\t\t\t\t\tcurrentDependency.clearValue();\n\t\t\t\t\tstartNode.after(currentValue);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tlet currentNode = startNode.nextSibling;\n\t\t\t\tlet newNodeIndex = 0;\n\t\t\t\tlet index = 0;\n\t\t\t\tif (currentValue._$wompChildren) {\n\t\t\t\t\tconst childrenNodes = (currentValue as WompChildren).nodes;\n\t\t\t\t\twhile (index < childrenNodes.length) {\n\t\t\t\t\t\tif (!currentNode || index === 0) currentNode = startNode;\n\t\t\t\t\t\tconst newNode = childrenNodes[newNodeIndex];\n\t\t\t\t\t\tnewNodeIndex++;\n\t\t\t\t\t\tcurrentNode.after(newNode);\n\t\t\t\t\t\tcurrentNode = currentNode.nextSibling;\n\t\t\t\t\t\tindex++;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tif (Array.isArray(currentValue)) {\n\t\t\t\t\t\tif (!(oldValue as WompArrayDependency)?.isArrayDependency) {\n\t\t\t\t\t\t\tcurrentDependency.clearValue();\n\t\t\t\t\t\t\tnewValues[i] = new WompArrayDependency(currentValue, currentDependency);\n\t\t\t\t\t\t} else newValues[i] = (oldValue as WompArrayDependency).checkUpdates(currentValue);\n\t\t\t\t\t} else if (DEV_MODE) {\n\t\t\t\t\t\tconsole.warn(\n\t\t\t\t\t\t\t'Rendering objects is not supported. Doing a stringified version of it can rise errors.\\n' +\n\t\t\t\t\t\t\t\t'This node will be ignored.'\n\t\t\t\t\t\t);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t} else if (currentDependency.isAttr) {\n\t\t\tconst attrName = currentDependency.name;\n\t\t\tif (attrName.startsWith('@')) {\n\t\t\t\tcurrentDependency.callback = currentValue;\n\t\t\t} else {\n\t\t\t\tconst attrStructure = currentDependency.attrStructure;\n\t\t\t\tif (attrStructure) {\n\t\t\t\t\tconst parts = attrStructure.split(WC_MARKER);\n\t\t\t\t\tlet dynamicValue = currentValue;\n\t\t\t\t\tfor (let j = 0; j < parts.length - 1; j++) {\n\t\t\t\t\t\tparts[j] = `${parts[j]}${dynamicValue}`;\n\t\t\t\t\t\ti++; // Go to the next dynamic value\n\t\t\t\t\t\tdynamicValue = newValues[i];\n\t\t\t\t\t}\n\t\t\t\t\ti--; // Since it'll be already increased in the loop, decrease by one\n\t\t\t\t\tcurrentDependency.updateValue(parts.join('').trim());\n\t\t\t\t} else {\n\t\t\t\t\tcurrentDependency.updateValue(currentValue);\n\t\t\t\t}\n\t\t\t}\n\t\t} else if (currentDependency.isTag) {\n\t\t\tconst node = currentDependency.node;\n\t\t\tlet customElement: HTMLElement = null;\n\t\t\tconst isCustomComponent = currentValue._$wompF;\n\t\t\tconst newNodeName: string = isCustomComponent ? currentValue.componentName : currentValue;\n\t\t\tif (node.nodeName !== newNodeName.toUpperCase()) {\n\t\t\t\tconst oldAttributes = (node as HTMLElement).getAttributeNames();\n\t\t\t\tif (isCustomComponent) {\n\t\t\t\t\t// Is a Womp Element\n\t\t\t\t\tif (DEV_MODE) {\n\t\t\t\t\t\tif ((node as WompElement)._$womp) {\n\t\t\t\t\t\t\tconsole.error(\n\t\t\t\t\t\t\t\t'Dynamic tags are currently not supported, unsless used to render for the first ' +\n\t\t\t\t\t\t\t\t\t'time a custom component.\\nInstead, you can use conditional rendering.\\n' +\n\t\t\t\t\t\t\t\t\t'(e.g. condition ? html`<${First} />` : html`<${Second} />`).'\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tconst initialProps: any = {};\n\t\t\t\t\tfor (const attrName of oldAttributes) {\n\t\t\t\t\t\t// attributes on the dom will be set when creating the element\n\t\t\t\t\t\tconst attrValue = (node as HTMLElement).getAttribute(attrName);\n\t\t\t\t\t\tinitialProps[attrName] = attrValue === '' ? true : attrValue;\n\t\t\t\t\t}\n\t\t\t\t\tcustomElement = new currentValue.class() as WompElement;\n\t\t\t\t\t(customElement as WompElement)._$initialProps = initialProps;\n\t\t\t\t\tconst childNodes = node.childNodes;\n\t\t\t\t\twhile (childNodes.length) {\n\t\t\t\t\t\tcustomElement.appendChild(childNodes[0]);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\t// Is normal element\n\t\t\t\t\tcustomElement = document.createElement(newNodeName);\n\t\t\t\t\tfor (const attrName of oldAttributes) {\n\t\t\t\t\t\tcustomElement.setAttribute(attrName, (node as HTMLElement).getAttribute(attrName));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tlet index = i;\n\t\t\t\tlet currentDynamic = dynamics[index] as DynamicAttribute;\n\t\t\t\twhile (currentDynamic?.node === node) {\n\t\t\t\t\t// Update node pointer of dynamics pointing to the old one.\n\t\t\t\t\tcurrentDynamic.node = customElement;\n\t\t\t\t\tcurrentDynamic = dynamics[++index] as DynamicAttribute;\n\t\t\t\t\t// Set initial props of the correct type, so a number doesn't become a string\n\t\t\t\t\tif (currentDynamic?.name && currentDynamic?.name !== 'ref')\n\t\t\t\t\t\t((customElement as WompElement)._$initialProps as any)[currentDynamic.name] =\n\t\t\t\t\t\t\tvalues[index];\n\t\t\t\t}\n\t\t\t\tnode.replaceWith(customElement);\n\t\t\t}\n\t\t}\n\t}\n\treturn newValues;\n};\n\n/* \n================================================\nWOMP COMPONENT DEFINITION\n================================================\n*/\n/**\n * This function will convert the functional component into an extension class of the HTMLElement,\n * so that it can be used to create the custom web-component.\n * @param Component The Component function\n * @param options The options of the component.\n * @returns A new dynamic class that will be used to create the custom web-component\n */\nconst _$womp = <Props, E>(\n\tComponent: WompComponent,\n\toptions: WompComponentOptions\n): WompElementClass<Props, E> => {\n\tconst [generatedCSS, styles] = __generateSpecifcStyles(Component, options);\n\tconst style = document.createElement('style');\n\tconst styleClassName = `${options.name}__styles`;\n\tif (generatedCSS) {\n\t\tstyle.classList.add(styleClassName);\n\t\tstyle.textContent = generatedCSS;\n\t\tif (!options.shadow) {\n\t\t\tdocument.body.appendChild(style);\n\t\t}\n\t}\n\t/**\n\t * The dynamic class created to make it possible to create a custom web-component\n\t */\n\tconst WompComponent = class extends HTMLElement implements WompElement {\n\t\tstatic _$womp = true; // For faster access\n\n\t\t/** The component name, used in the DOM */\n\t\tstatic componentName = options.name;\n\t\t/**\n\t\t * The cached template created in the first item's render, and then reused across all\n\t\t * components.\n\t\t */\n\t\tstatic _$cachedTemplate: CachedTemplate;\n\n\t\t/**\n\t\t * Get the already present cached template, or create a new one if the component is rendering\n\t\t * for the first time.\n\t\t * @param parts The template parts from the html function.\n\t\t * @returns The cached template.\n\t\t */\n\t\tstatic _$getOrCreateTemplate(parts: TemplateStringsArray) {\n\t\t\tif (!this._$cachedTemplate) this._$cachedTemplate = __createTemplate(parts);\n\t\t\treturn this._$cachedTemplate;\n\t\t}\n\n\t\tpublic _$womp: true = true; // For faster access\n\n\t\tpublic props: WompProps = {};\n\t\tpublic _$hooks: Hook[] = [];\n\t\tpublic _$measurePerf: boolean = false;\n\t\tpublic _$initialProps: WompProps = {} as any;\n\t\tpublic _$usesContext: boolean = false;\n\t\tpublic _$hasBeenMoved: boolean = false;\n\n\t\t/** The Root. It'll be the node itself, or it's ShadowRoot if shadow is set to true */\n\t\tprivate __ROOT: this | ShadowRoot;\n\t\t/** The array containing metadata of the component, used to render the component */\n\t\tprivate __dynamics: Dynamics[];\n\t\t/** It'll be true if the component has already processing an update. */\n\t\tprivate __updating: boolean = false;\n\t\t/** The array containing the dynamic values of the last render. */\n\t\tprivate __oldValues: any[] = [];\n\t\t/** It'll be true if the component is currently initializing. */\n\t\tprivate __isInitializing: boolean = true;\n\t\t/** It's true if the component is connected to the DOM. */\n\t\tprivate __connected: boolean = false;\n\t\t/**\n\t\t * Used to know if a component has been completely removed from the DOM or only temporarely to\n\t\t * move it from a node to another.\n\t\t */\n\t\tprivate __isInDOM: boolean = false;\n\n\t\tconstructor() {\n\t\t\tsuper();\n\t\t}\n\n\t\t/** @override component has been connected to the DOM */\n\t\tconnectedCallback() {\n\t\t\tthis.__isInDOM = true;\n\t\t\tif (!this.__connected && this.isConnected) this.initElement();\n\t\t}\n\n\t\t/** @override component has been disconnected from the DOM */\n\t\tdisconnectedCallback() {\n\t\t\t// When a component is just \"moved\" to another element but not\n\t\t\t// removed from the DOM, it still calls the disconnected and\n\t\t\t// then the connected callback again. This prevents it.\n\t\t\tif (this.__connected) {\n\t\t\t\tthis.__isInDOM = false;\n\t\t\t\tPromise.resolve().then(() => {\n\t\t\t\t\t// If the connectedCallback is called again, isInTheDOM will be true\n\t\t\t\t\tif (!this.__isInDOM) {\n\t\t\t\t\t\tthis.onDisconnected();\n\t\t\t\t\t\tif (DEV_MODE) console.warn('Disconnected', this);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tthis._$hasBeenMoved = true;\n\t\t\t\t\t\tif (this._$usesContext) this.requestRender();\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t}\n\t\t}\n\n\t\t/**\n\t\t * This public callback will be used when a component is removed permanently from the DOM.\n\t\t * It allows other code to hook into the component and unmount listeners or similar when the\n\t\t * component is disconnected from the DOM.\n\t\t */\n\t\tpublic onDisconnected() {}\n\n\t\t/**\n\t\t * Initializes the component with the state, props, and styles.\n\t\t */\n\t\tprivate initElement() {\n\t\t\tthis.__ROOT = this; // Shadow DOM is eventually attached later\n\t\t\tthis.props = {\n\t\t\t\t...this.props,\n\t\t\t\t...this._$initialProps,\n\t\t\t\tstyles: styles,\n\t\t\t} as any;\n\t\t\tconst componentAttributes = this.getAttributeNames();\n\t\t\tfor (const attrName of componentAttributes) {\n\t\t\t\tif (!this.props.hasOwnProperty(attrName)) {\n\t\t\t\t\tconst attrValue = this.getAttribute(attrName);\n\t\t\t\t\t(this.props as any)[attrName] = attrValue === '' ? true : attrValue;\n\t\t\t\t}\n\t\t\t\tif (DEV_MODE && attrName === 'wc-perf') {\n\t\t\t\t\tthis._$measurePerf = true;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (DEV_MODE && this.props['wc-perf']) {\n\t\t\t\tthis._$measurePerf = true;\n\t\t\t}\n\n\t\t\tif (DEV_MODE && this._$measurePerf) console.time('First render ' + options.name);\n\t\t\t// The children are saved in a WompChildren instance, so that\n\t\t\t// they are not lost even when disconnected from the DOM.\n\t\t\tconst childNodes = this.__ROOT.childNodes;\n\t\t\tconst childrenArray: Node[] = [];\n\t\t\t// Removing items from the DOM doesn't delete them.\n\t\t\twhile (childNodes.length) {\n\t\t\t\tchildrenArray.push(childNodes[0]);\n\t\t\t\tchildNodes[0].remove();\n\t\t\t}\n\t\t\tconst children = new WompChildren(childrenArray);\n\t\t\tthis.props.children = children;\n\n\t\t\t// Create shadow DOM\n\t\t\tif (options.shadow) this.__ROOT = this.attachShadow({ mode: 'open' });\n\n\t\t\t// Attach styles only if we are inside a shadow root and the same style is\n\t\t\t// not already present.\n\t\t\tconst root = this.getRootNode();\n\t\t\tif (\n\t\t\t\t(options.shadow || root !== document.body) &&\n\t\t\t\t!(root as ShadowRoot).querySelector(`.${styleClassName}`)\n\t\t\t) {\n\t\t\t\tconst clonedStyles = style.cloneNode(true);\n\t\t\t\tthis.__ROOT.appendChild(clonedStyles);\n\t\t\t}\n\n\t\t\tconst renderHtml = this.__callComponent();\n\t\t\tconst { values, parts } = renderHtml;\n\t\t\tconst template = (this.constructor as typeof WompComponent)._$getOrCreateTemplate(parts);\n\t\t\tconst [fragment, dynamics] = template.clone();\n\t\t\tthis.__dynamics = dynamics;\n\t\t\tconst elaboratedValues = __setValues(this.__dynamics, values, this.__oldValues);\n\t\t\tthis.__oldValues = elaboratedValues;\n\n\t\t\twhile (fragment.childNodes.length) {\n\t\t\t\tthis.__ROOT.appendChild(fragment.childNodes[0]);\n\t\t\t}\n\t\t\tthis.__isInitializing = false;\n\t\t\tthis.__connected = true;\n\t\t\tif (DEV_MODE && this._$measurePerf) console.timeEnd('First render ' + options.name);\n\t\t}\n\n\t\t/**\n\t\t * Calls the functional component by first setting correct values to the\n\t\t * [currentRenderingComponent] and [currentHookIndex] variables.\n\t\t * @returns The result of the call.\n\t\t */\n\t\tprivate __callComponent() {\n\t\t\tcurrentRenderingComponent = this;\n\t\t\tcurrentHookIndex = 0;\n\t\t\tconst result = Component.call(this, this.props);\n\t\t\tlet renderHtml: RenderHtml = result as RenderHtml;\n\t\t\tif (typeof result === 'string' || result instanceof HTMLElement) renderHtml = html`${result}`;\n\t\t\treturn renderHtml;\n\t\t}\n\n\t\t/**\n\t\t * It requests a render to the component. If the component has already received a render\n\t\t * request, the request will be rejected. This is to avoid multiple re-renders when it's not\n\t\t * necessary. The following function will cause a single re-render:\n\t\t * ```javascript\n\t\t * const incBy2 = () => {\n\t\t *   setState((oldState) => oldState + 1)\n\t\t *   setState((oldState) => oldState + 1)\n\t\t * }\n\t\t * ```\n\t\t */\n\t\tpublic requestRender() {\n\t\t\tif (!this.__updating) {\n\t\t\t\tthis.__updating = true;\n\t\t\t\tPromise.resolve().then(() => {\n\t\t\t\t\tif (DEV_MODE && this._$measurePerf) console.time('Re-render ' + options.name);\n\t\t\t\t\tconst renderHtml = this.__callComponent();\n\t\t\t\t\tconst oldValues = __setValues(this.__dynamics, renderHtml.values, this.__oldValues);\n\t\t\t\t\tthis.__oldValues = oldValues;\n\t\t\t\t\tthis.__updating = false;\n\t\t\t\t\tthis._$hasBeenMoved = false;\n\t\t\t\t\tif (DEV_MODE && this._$measurePerf) console.timeEnd('Re-render ' + options.name);\n\t\t\t\t});\n\t\t\t}\n\t\t}\n\n\t\t/**\n\t\t * It'll set a new value to a specific prop of the component, and a re-render will be requested.\n\t\t * @param prop The prop name.\n\t\t * @param value The new value to set.\n\t\t */\n\t\tpublic updateProps(prop: string, value: any) {\n\t\t\tif ((this.props as any)[prop] !== value) {\n\t\t\t\t(this.props as any)[prop] = value;\n\t\t\t\tif (!this.__isInitializing) {\n\t\t\t\t\tconsole.warn(`Updating ${prop}`, this.__isInitializing);\n\t\t\t\t\tthis.requestRender();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t};\n\treturn WompComponent as unknown as WompElementClass<Props, E>;\n};\n\n/* \n================================================\nHOOKS\n================================================\n*/\n\n/**\n * This generic hook will allow the creation of custom hooks by exposing the current rendering\n * component and the current hook index. They will be returned in an array of 2 element:\n * [currentComponent, currentIndex].\n * The currentHookIndex will be then automatically incremented, so that the developer will not have\n * to worry about it, avoiding potential bugs.\n * @returns The current rendering component and current index.\n */\nexport const useHook = (): [WompElement, number] => {\n\tconst currentComponent = currentRenderingComponent;\n\tconst currentIndex = currentHookIndex;\n\tconst res: [WompElement, number] = [currentComponent, currentIndex];\n\tcurrentHookIndex++;\n\treturn res;\n};\n\n/**\n * This hook will allow a component to request a re-render when the property changes. It accepts one\n * parameter, which is the initial value, and it'll return an array containing 2 values: the current\n * value and a function to update it. The value will not be directly modifiable: it's necessary to\n * call the set function with the new value. The set function can be:\n *\n * 1. The new value\n * 2. A function that has the old state as a parameter, and returns the new value.\n *\n * The second case should be used in the following conditions:\n *\n * - Consecutive updates are performed consecutively\n * - The update is performed inside a callback function that is not re-created during render.\n *\n * If the state value is an object, to update it you must pass the whole object back: this hook will\n * not do a merge of the partial value and the old value. If you prefer this to happen, you should\n * apply the `useReducer` approach instead.\n *\n * @example\n * ```javascript\n * function Counter(){\n *   const [counter, setCounter] = useState(0);\n *   const inc = () => setCounter(counter+1);\n *   return html`<button \\@click=${inc}>${counter}</button>`;\n * }\n * ```\n *\n * @param defaultValue The starter value.\n * @returns The current StateHook value.\n */\nexport const useState = <S>(defaultValue: S) => {\n\tconst [component, hookIndex] = useHook();\n\tif (!component._$hooks.hasOwnProperty(hookIndex)) {\n\t\tconst index = hookIndex;\n\t\tcomponent._$hooks[index] = [\n\t\t\tdefaultValue,\n\t\t\t(newValue: S) => {\n\t\t\t\tlet computedValue = newValue;\n\t\t\t\tconst stateHook = component._$hooks[index] as StateHook<S>;\n\t\t\t\tif (typeof newValue === 'function') {\n\t\t\t\t\tcomputedValue = newValue(stateHook[0]);\n\t\t\t\t}\n\t\t\t\tif (computedValue !== stateHook[0]) {\n\t\t\t\t\tstateHook[0] = computedValue;\n\t\t\t\t\tcomponent.requestRender();\n\t\t\t\t}\n\t\t\t},\n\t\t];\n\t}\n\tconst state = component._$hooks[hookIndex] as StateHook<S>;\n\treturn state;\n};\n\n/**\n * The useEffect hook allows to execute a callback (passed in the first argument) on first render\n * and whenever one of the dependencies changes (second argument). This is useful to execute async\n * calls, set intervals, and other types of initialization in the component.\n * The list of dependencies can be an empty array: in this case, the callback function will only be\n * executed once, that is after the first render.\n * The callback gets executed asynchronously, meaning that it'll be executed once the component will\n * finish its rendering phase.\n *\n * @example\n * ```javascript\n * function Timer(){\n *   const [time, setTime] = useState(0);\n *   useEffect(() => {\n *     setInterval(() => {\n *       setTime((oldTime) => oldTime + 1);\n *     }, 10)\n *   }, [])\n *   return html`Time: ${(time/100).toFixed(2)}s`\n * }\n * ```\n * @param callback The callback to execute when a dependency changes.\n * @param dependencies The list of dependencies to listen to changes.\n */\nexport const useEffect = (callback: VoidFunction | (() => VoidFunction), dependencies: any[]) => {\n\tconst [component, hookIndex] = useHook();\n\tif (!component._$hooks.hasOwnProperty(hookIndex)) {\n\t\tconst effectHook = {\n\t\t\tdependencies: dependencies,\n\t\t\tcallback: callback,\n\t\t\tcleanupFunction: null,\n\t\t} as EffectHook;\n\t\tcomponent._$hooks[hookIndex] = effectHook;\n\t\tPromise.resolve().then(() => {\n\t\t\teffectHook.cleanupFunction = callback();\n\t\t});\n\t} else {\n\t\tconst componentEffect = component._$hooks[hookIndex] as EffectHook;\n\t\tfor (let i = 0; i < dependencies.length; i++) {\n\t\t\tconst oldDep = componentEffect.dependencies[i];\n\t\t\tif (oldDep !== dependencies[i]) {\n\t\t\t\tif (typeof componentEffect.cleanupFunction === 'function')\n\t\t\t\t\tcomponentEffect.cleanupFunction();\n\t\t\t\tPromise.resolve().then(() => {\n\t\t\t\t\tcomponentEffect.cleanupFunction = callback();\n\t\t\t\t\tcomponentEffect.dependencies = dependencies;\n\t\t\t\t});\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n};\n\n/**\n * The useLayoutEffect hook is the same as the main useEffect hook. The only difference stands in\n * the execution order: the useEffect hook gets executed asynchronously, so the component will first\n * render, and then it'll call the callback. The useLayoutEffect hook gets executed synchronously,\n * so `before` the component renders.\n * @param callback The callback to execute\n * @param dependencies The list of dependencies to listen to changes.\n */\nexport const useLayoutEffect = (\n\tcallback: VoidFunction | (() => VoidFunction),\n\tdependencies: any[]\n) => {\n\tconst [component, hookIndex] = useHook();\n\tif (!component._$hooks.hasOwnProperty(hookIndex)) {\n\t\tconst effectHook = {\n\t\t\tdependencies: dependencies,\n\t\t\tcallback: callback,\n\t\t\tcleanupFunction: null,\n\t\t} as EffectHook;\n\t\tcomponent._$hooks[hookIndex] = effectHook;\n\t\teffectHook.cleanupFunction = callback();\n\t} else {\n\t\tconst componentEffect = component._$hooks[hookIndex] as EffectHook;\n\t\tfor (let i = 0; i < dependencies.length; i++) {\n\t\t\tconst oldDep = componentEffect.dependencies[i];\n\t\t\tif (oldDep !== dependencies[i]) {\n\t\t\t\tif (typeof componentEffect.cleanupFunction === 'function')\n\t\t\t\t\tcomponentEffect.cleanupFunction();\n\t\t\t\tcomponentEffect.cleanupFunction = callback();\n\t\t\t\tcomponentEffect.dependencies = dependencies;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n};\n\n/**\n * The useRef hook is very similar to the `useState` hook. The only difference is that the useRef\n * hook will NOT re-render the component, and the value will be accessed through the `.current`\n * property. This is useful if you want to keep a stable value of a variable across all the renders,\n * (without re-initializing the variable and loose it's previous state), but without causing a\n * re-render when the value changes.\n * If the value is passed to a \"ref\" attribute in any node, the .current value will be set to the\n * node having that attribute.\n *\n * @example\n * ```javascript\n * function Component(){\n *   const divRef = useRef();\n *   console.log(divRef.current); // null\n *   useEffect(() => {\n *     console.log(divRef.current); // HTMLDivElement\n *   }, []);\n *   return html`<div ref=${divRef}>I have a reference!</div>`;\n * }\n * ```\n *\n * @param initialValue The initial value.\n * @returns The current value of the reference.\n */\nexport const useRef = <T>(initialValue: T = null) => {\n\tconst [component, hookIndex] = useHook();\n\tif (!component._$hooks.hasOwnProperty(hookIndex)) {\n\t\tcomponent._$hooks[hookIndex] = {\n\t\t\tcurrent: initialValue,\n\t\t\t__wcRef: true,\n\t\t} as RefHook<T>;\n\t}\n\tconst ref = component._$hooks[hookIndex] as RefHook<T>;\n\treturn ref;\n};\n\n/**\n * The useCallback hook is a useful hook that stores the given function and returns the same\n * function in the next renders.\n * Why is it useful? Because in javascript 2 function declarations are considered not equal:\n *\n * ```javascript\n * () => {} === () => {} // false\n *\n * const a = () => {}\n * a === a // true\n * ```\n *\n * So, for example, a useful case in which to use it, is when a callback function is passed through\n * the props of another component: if you don't use the `useCallback` hook, the child component will\n * re-render every time the parent component changes, because the two functions will be considered\n * different.\n * This consideration doesn't apply to events, because events are stored in a simple variable and\n * will not cause an add/removal of event listeners, so it's not computationally expensive: it's\n * more expensive to store the callback and get it back every time.\n *\n * @example\n * ```javascript\n * function Component(){\n *   const callback = useCallback(() => console.log('Hey!'));\n *   return html`<${NestedComponent} hey=${callback} />`\n * }\n * ```\n *\n * @param callbackFn The callback function to save.\n * @returns The stored callback function.\n */\nexport const useCallback = (callbackFn: CallbackHook) => {\n\tconst [component, hookIndex] = useHook();\n\tif (!component._$hooks.hasOwnProperty(hookIndex)) {\n\t\tcomponent._$hooks[hookIndex] = callbackFn;\n\t}\n\tconst callback = component._$hooks[hookIndex];\n\treturn callback as CallbackHook;\n};\n\nconst useIdMemo = () => {\n\tlet counter = 0;\n\treturn () => {\n\t\tconst [component, hookIndex] = useHook();\n\t\tif (!component._$hooks.hasOwnProperty(hookIndex)) {\n\t\t\tcomponent._$hooks[hookIndex] = `:r${counter}:` as IdHook;\n\t\t\tcounter++;\n\t\t}\n\t\tconst callback = component._$hooks[hookIndex];\n\t\treturn callback as IdHook;\n\t};\n};\n/**\n * The useId hook returns a unique id for the component. It's simply a counter that gets updated\n * every time a component instantiates this hook. The id structure will be the following: \":r0:\".\n *\n * Since the purpose of component is their reusability, a component should not have an element with\n * a static Id. That's when this function comes into play. The id can be used also for accessibility\n * purposes.\n *\n * @example\n * ```javascript\n * function Input(){\n *   const id = useId();\n *   return html`\n *     <input id=${id} type=\"checkbox\" />\n *     <label for=${id}>Input</label>\n *   `\n * }\n * ```\n *\n * @returns The useId hook.\n */\nexport const useId = useIdMemo();\n\n/**\n * The useMemo hook is useful when you want to store a computed value which would be expensive to\n * re-compute for every single render. For example, filtering or sorting, an array. It accepts one\n * callback function and will return the result of it. The second parameter contains the\n * dependencies that will cause the re-execution of the callback function when one of them changes.\n *\n * @example\n * ```javascript\n *\n * const users = [...] // thousands of users.\n *\n * function Users(){\n *   const adults = useMemo(() => {\n *     return users.filter(user => user.age >= 18);\n *   }, [users])\n *   return html`<ul>\n *     ${adults.map(user => html`<li>${user.name}</li>`)}\n *   </ul>`\n * }\n * ```\n *\n * @param callbackFn The callback function to execute.\n * @param dependencies The depencies to listen to changes.\n * @returns The last computed result.\n */\nexport const useMemo = (callbackFn: () => any, dependencies: any[]) => {\n\tconst [component, hookIndex] = useHook();\n\tif (!component._$hooks.hasOwnProperty(hookIndex)) {\n\t\tcomponent._$hooks[hookIndex] = {\n\t\t\tvalue: callbackFn(),\n\t\t\tdependencies: dependencies,\n\t\t} as MemoHook;\n\t} else {\n\t\tconst oldMemo = component._$hooks[hookIndex] as MemoHook;\n\t\tfor (let i = 0; i < dependencies.length; i++) {\n\t\t\tconst oldDep = oldMemo.dependencies[i];\n\t\t\tif (oldDep !== dependencies[i]) {\n\t\t\t\toldMemo.dependencies = dependencies;\n\t\t\t\toldMemo.value = callbackFn();\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tconst memoizedResult = component._$hooks[hookIndex] as MemoHook;\n\treturn memoizedResult.value;\n};\n\n/**\n * The useReducer hook is an alternative approach for `useState`, using the redux-like state\n * management.\n * With this hook, you give as a parameter the initial state and the reducer function. This function\n * must accept 2 parameters: the old state, and the action, which is an object having at least the\n * \"type\" key (which is a string corresponding to the action to execute). The reducer must return\n * the new (partial) state.\n * The useReducer function will then return the current state and the **dispatch** function. This\n * function, unlike the simple set function generated by the `useState` hook, will accept a single\n * parameter which is the action to pass to the reducer function.\n *\n * @example\n * ```javascript\n * const reducer = (oldState, action) => {\n *   switch (action.type) {\n *     case 'ADD_SHEEP':\n *       return { sheeps: oldState.sheeps + 1 };\n *     case 'ADD_COW':\n *       return { cows: oldState.cows + 1 };\n *     default:\n *       throw new Error('Action not supported');\n *   }\n * }\n *\n * const initialState = { sheeps: 10, cows: 5 };\n *\n * function SheepsAndCows(){\n *   const [state, dispatch] = useReducer(initialState, reducer);\n *   const addSheep = () => dispatch({ type: 'ADD_SHEEP' })\n *   const addCow = () => dispatch({ type: 'ADD_COW' })\n *   return html`\n *     <button \\@click=${addSheep}>Sheeps: ${state.sheeps}</button>\n *     <button \\@click=${addCow}>Cows: ${state.cows}</button>\n *   `\n * }\n * ```\n *\n * @param reducer The reducer function.\n * @param initialState The initial state.\n * @returns An array with [state, dispath].\n */\nexport const useReducer = <State>(\n\treducer: (state: State, action: ReducerAction) => Partial<State>,\n\tinitialState: State\n) => {\n\tconst [component, hookIndex] = useHook();\n\tconst index = hookIndex;\n\tif (!component._$hooks.hasOwnProperty(index)) {\n\t\tconst dispatch = (action: ReducerAction) => {\n\t\t\tconst currentState = (component._$hooks[index] as ReducerHook<State>)[0];\n\t\t\tconst partialState = reducer(currentState, action);\n\t\t\tconst keys = Object.keys(partialState);\n\t\t\tfor (const key of keys) {\n\t\t\t\tif ((partialState as any)[key] !== (currentState as any)[key]) {\n\t\t\t\t\tcomponent.requestRender();\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tconst newState = {\n\t\t\t\t...currentState,\n\t\t\t\t...partialState,\n\t\t\t} as State;\n\t\t\t(component._$hooks[hookIndex] as ReducerHook<State>)[0] = newState;\n\t\t};\n\t\tconst reducerHook: ReducerHook<State> = [initialState, dispatch];\n\t\tcomponent._$hooks[hookIndex] = reducerHook;\n\t}\n\tconst stateAndReducer = component._$hooks[hookIndex];\n\treturn stateAndReducer;\n};\n\n/**\n * The useExposed hook allows the component to expose variables and/or methods in the DOM. Sometimes\n * you want to be able to select an element in the DOM and then use one of it's methods to do some\n * kind of operations. Some components are better to have an \"isolated\" state, meaning that it's\n * rendering state should be internal, and not depending to its props. A nice example it's a modal:\n * you'd rather want to have an `open()` method that having an `open` property, that causes a\n * re-render of the parent and the modal component.\n *\n * This is a different approach compared to React, but using exposed methods in custom elements can\n * have great benefits speaking about performances in comparison of using props to manage the state.\n *\n * This hook accepts an object having as keys the name of the property to expose and the\n * corresponding values.\n * The `useExposed` hook is a great combination with the `useRef` hook.\n *\n * @example\n * ```javascript\n * function Modal(){\n *   const [open, setOpen] = useState(false);\n *   const openModal = () => setOpen(true);\n *   const closeModal = () => setOpen(false);\n *   useExposed({\n *     open: openModal,\n *     close: closeModal,\n *   });\n *   return html`...`;\n * }\n *\n * function ParentComponent(){\n *   const modalRef = useRef();\n *   /// Will only re-render the modal component, and not this component.\n *   const openModal = () => modalRef.current.open();\n *   return html`\n *     <button \\@click=${openModal}>Open Modal</button>\n *     <${Modal} ref=${modalRef} />\n *   `\n * }\n * ```\n *\n * @param toExpose The keys to expose.\n */\nexport const useExposed = <E = {}>(toExpose: E) => {\n\tconst component = currentRenderingComponent;\n\tconst keys = Object.keys(toExpose) as (keyof E)[];\n\tfor (const key of keys) {\n\t\t(component as any)[key] = toExpose[key];\n\t}\n};\n\n//? NO useDebugValue (because is for react-dev-tools)\n//? NO useDeferredValue\n//? NO useImperativeHandle\n//? NO useInsertionEffect\n//? NO useOptimistic\n\n/* \n================================================\nCONTEXT\n================================================\n*/\n\n/**\n * The Context interface\n */\ninterface Context<S = any> {\n\tProvider: WompComponent<ContextProviderProps>;\n\tdefault: S;\n\tname: string;\n}\n\nconst createContextMemo = () => {\n\tlet contextIdentifier = 0;\n\treturn <S>(initialValue: S): Context<S> => {\n\t\tconst name = `womp-context-provider-${contextIdentifier}`;\n\t\tcontextIdentifier++;\n\t\tconst ProviderFunction = defineWomp<ContextProviderProps, ContextProviderExposed>(\n\t\t\t({ children }: ContextProviderProps) => {\n\t\t\t\tconst initialSubscribers = new Set<WompElement>();\n\t\t\t\tconst subscribers = useRef(initialSubscribers);\n\t\t\t\tuseExposed({ subscribers: subscribers });\n\t\t\t\tsubscribers.current.forEach((el) => el.requestRender());\n\t\t\t\treturn html`${children}`;\n\t\t\t},\n\t\t\t{\n\t\t\t\tname: name,\n\t\t\t\tcssGeneration: false,\n\t\t\t}\n\t\t);\n\t\tconst Context = {\n\t\t\tname: name,\n\t\t\tProvider: ProviderFunction,\n\t\t\tdefault: initialValue,\n\t\t\tsubscribers: new Set<WompElement>(),\n\t\t};\n\t\treturn Context;\n\t};\n};\n\n/**\n * The createContext function returns a Context instance that can be used to pass down a property\n * to all its children. This can be quite useful to avoid passing down props infinitely.\n * The function accepts a single parameter, that is the default value that will be used if a\n * component requires a context that does't have a parent providing the requested value.\n *\n * To initialize the component you'll have to put in the DOM the Context.Provider instance, which\n * accepts a single prop: value. This value will then be passed down to the components that use the\n * `useContext` hook.\n *\n * @example\n * ```javascript\n * const ThemeContext = createContext('light');\n *\n * function App(){\n *   const [theme, setTheme] = useState('light');\n *   const toggle = () => {\n *     if(theme === 'light') setTheme('dark');\n *     if(theme === 'dark') setTheme('light');\n *   }\n *   return html`\n *     <button \\@click=${toggle}>Toggle Theme</button>\n *     <${ThemeContext.Provider} value=${theme}>\n *       <${CompWithTheme} />\n *     </${ThemeContext.Provider}>\n *   `;\n * }\n *\n * function CompWithTheme(){\n *   const theme = useContext(ThemeContext);\n *   return html`<p>Current Theme: ${theme}.</p>`;\n * }\n * ```\n */\nexport const createContext = createContextMemo();\n\n/**\n * The useContext hook is used to obtain the current value provided bya a parent Context.Provider\n * element. The context must be created first with the `createContext` function.\n * @param Context The context to use.\n * @returns The value of the context above the element.\n */\nexport const useContext = (Context: Context) => {\n\tconst [component, hookIndex] = useHook();\n\tcomponent._$usesContext = true;\n\tif (!component._$hooks.hasOwnProperty(hookIndex) || component._$hasBeenMoved) {\n\t\tlet parent = component as Node;\n\t\tconst toFind = Context.name.toUpperCase();\n\t\twhile (parent && parent.nodeName !== toFind && parent !== document.body) {\n\t\t\tif (parent instanceof ShadowRoot) parent = parent.host;\n\t\t\telse parent = parent.parentNode;\n\t\t}\n\t\tconst oldParent = (component._$hooks[hookIndex] as ContextHook)?.node;\n\t\tif (parent && parent !== document.body) {\n\t\t\t(parent as ContextInstance).subscribers.current.add(component);\n\t\t\tconst oldDisconnect = component.onDisconnected;\n\t\t\tcomponent.onDisconnected = () => {\n\t\t\t\t(parent as ContextInstance).subscribers.current.delete(component);\n\t\t\t\toldDisconnect();\n\t\t\t};\n\t\t} else if (oldParent) {\n\t\t\tif (DEV_MODE) {\n\t\t\t\tconsole.warn(\n\t\t\t\t\t`The element ${component.tagName} doens't have access to the Context ${Context.name} ` +\n\t\t\t\t\t\t'because is no longer a child of it.'\n\t\t\t\t);\n\t\t\t}\n\t\t\toldParent.subscribers.current.delete(component);\n\t\t} else if (DEV_MODE && component.isConnected) {\n\t\t\tconsole.warn(\n\t\t\t\t`The element ${component.tagName} doens't have access to the Context ${Context.name}. ` +\n\t\t\t\t\t'The default value will be returned instead.'\n\t\t\t);\n\t\t}\n\t\tcomponent._$hooks[hookIndex] = {\n\t\t\tnode: parent,\n\t\t\tvalue:\n\t\t\t\tparent && parent !== document.body\n\t\t\t\t\t? (parent as ContextInstance).props.value\n\t\t\t\t\t: Context.default,\n\t\t} as ContextHook;\n\t}\n\tconst contextNode = (component._$hooks[hookIndex] as ContextHook).node;\n\treturn contextNode ? contextNode.props.value : Context.default;\n};\n\n/* \n================================================\nHTML\n================================================\n*/\n\n/**\n * This template function is used to then generate the DOM structure for a component.\n * Should be used as a return value for every component, and for every string value that contains\n * an HTML structure. Simple strings will be taken as they are, and will not be converted into HTML\n * nodes.\n *\n * @example\n * ```javascript\n * const greeting = 'Hello, world!';\n * const template = html`<div>${greeting}</div>`\n * ```\n * @param template The list of static strings of the template\n * @param values The list of dynamic values of the template\n */\nexport function html(templateParts: TemplateStringsArray, ...values: any[]): RenderHtml {\n\tconst cleanValues = [];\n\tconst length = templateParts.length - 1; // skip last element\n\tif (!IS_SERVER) {\n\t\tfor (let i = 0; i < length; i++) {\n\t\t\t// Don't include dynamic closing tags\n\t\t\tif (!templateParts[i].endsWith('</')) cleanValues.push(values[i]);\n\t\t}\n\t} else {\n\t\tcleanValues.push(...values);\n\t}\n\treturn {\n\t\tparts: templateParts,\n\t\tvalues: cleanValues,\n\t\t_$wompHtml: true,\n\t};\n}\n\n/* \n================================================\nDEFAULT OPTIONS\n================================================\n*/\n/**\n * The default options used when creating a Web Component. If you customize these options, you\n * should do it at the TOP of your html file, before every other component renders.\n * The current options are:\n * - `shadow`: false (boolean)\n * - `cssGeneration`: true (boolean)\n */\nexport const wompDefaultOptions: WompComponentOptions = {\n\tshadow: false,\n\tname: '',\n\tcssGeneration: true,\n};\n\n/* \n================================================\nDEFINE WOMP COMPONENT\n================================================\n*/\n/**\n * The defineWomp function will be the trigger point to generate your custom web component.\n * It accepts 2 parameter: your functional component and the options to customize it.\n * The current available options are the followings:\n * - `name` (string)\n * - `shadow` (boolean).\n * - `cssGeneration` (boolean)\n *\n * The default values will depend on the [wompDefaultOptions] variable.\n *\n * The functional component can have the css property, wich is a string corresponding to its styles.\n *\n * The `name` of the component will be the one specified in the options, or, if not specified, will\n * be the hyphen-cased name of the functional component. If the generated name will not have at\n * least one hyphen, a \"-womp\" string will be appended in the end.\n * Example: function CounterComponent(){} -> counter-component\n * Example2: function Counter(){} -> counter-womp\n *\n * The `shadow` option, if true, will build the content of the component in a Shadow DOM.\n *\n * The `cssGeneration` option will transform the css of the component by replacing the classes with\n * unique names, that will then be passed in the `styles` props of the component.\n *\n * @example\n * ```javascript\n * function Greetings(){\n *   return html`<p>Hello World!</p>`\n * }\n * Greetings.css = `p { color: blue; }`\n *\n * export default defineWomp(Greetings, {\n *   name: 'greetings-component',\n *   shadow: true,\n * })\n * ```\n *\n * @param component The functional component.\n * @param options The options of the component.\n * @returns The generated class for the component.\n */\nexport function defineWomp<Props, E = {}>(\n\tcomponent: WompComponent<Props & WompProps>,\n\toptions?: WompComponentOptions\n) {\n\tif (!component.css) component.css = '';\n\tconst componentOptions = {\n\t\t...wompDefaultOptions,\n\t\t...(options || {}),\n\t};\n\tif (!componentOptions.name) {\n\t\tlet newName = component.name\n\t\t\t.replace(/.[A-Z]/g, (letter) => `${letter[0]}-${letter[1].toLowerCase()}`)\n\t\t\t.toLowerCase();\n\t\tif (!newName.includes('-')) newName += '-womp';\n\t\tcomponentOptions.name = newName;\n\t}\n\tcomponent.componentName = componentOptions.name;\n\tcomponent._$wompF = true;\n\tif (!IS_SERVER) {\n\t\tconst Component = _$womp<Props, E>(component, componentOptions);\n\t\tcomponent.class = Component;\n\t\tcustomElements.define(componentOptions.name, Component);\n\t}\n\treturn component as WompComponent<Props & WompProps>;\n}\n\n/* \n================================================\nJSX\n================================================\n*/\n/**\n * This function enables to use JSX to create Womp Components. It'll simply re-create the\n * functioning of the `html` tag template function, and will return a RenderHtml object.\n *\n * Note: Using JSX will have a small drop in performances: since with JSX you cannot know which are\n * the dynamic parts in a component, everything will be re-rendered.\n *\n * @param Element The tag name or custom element function.\n * @param attributes The attributes (props).\n * @returns A RenderHtml.\n */\nexport const jsx = (Element: any, attributes: { [key: string]: any }) => {\n\tconst template = {\n\t\tparts: [],\n\t\tvalues: [],\n\t\t_$wompHtml: true,\n\t} as { parts: string[]; values: any[]; _$wompHtml: true };\n\tlet tagName = Element;\n\tif (Element._$wompF) tagName = Element.componentName;\n\telse if (Element === Fragment) tagName = '';\n\tlet staticHtml = tagName ? `<${tagName}` : '';\n\tconst attrNames = Object.keys(attributes);\n\tfor (const attrName of attrNames) {\n\t\tif (attrName === 'children') {\n\t\t\tbreak;\n\t\t}\n\t\tconst isEvent = attrName.match(/on([A-Z].*)/);\n\t\tif (isEvent) {\n\t\t\tstaticHtml += ` @${isEvent[1].toLowerCase()}=`;\n\t\t} else {\n\t\t\tstaticHtml += ` ${attrName}=`;\n\t\t}\n\t\ttemplate.parts.push(staticHtml);\n\t\ttemplate.values.push(attributes[attrName]);\n\t\tstaticHtml = '';\n\t\t// Children is always the last key\n\t}\n\tstaticHtml += tagName ? '>' : '';\n\ttemplate.parts.push(staticHtml);\n\tconst children = attributes.children;\n\tif (children && children.parts) {\n\t\tif (attributes.children.parts) {\n\t\t\ttemplate.values.push(false); // NO value\n\t\t\ttemplate.parts.push(...attributes.children.parts);\n\t\t\ttemplate.values.push(...attributes.children.values);\n\t\t\ttemplate.values.push(false); // NO value\n\t\t} else if (Array.isArray(attributes.children)) {\n\t\t\tfor (const part of attributes.children) {\n\t\t\t\ttemplate.values.push(false); // NO value\n\t\t\t\ttemplate.parts.push(...part.parts);\n\t\t\t\ttemplate.values.push(...part.values);\n\t\t\t\ttemplate.values.push(false); // NO value\n\t\t\t}\n\t\t}\n\t} else {\n\t\ttemplate.values.push(children);\n\t}\n\tstaticHtml = tagName ? `</${tagName}>` : '';\n\ttemplate.parts.push(staticHtml);\n\t// }\n\treturn template as unknown as RenderHtml;\n};\n/** JSX Fragment */\nexport const Fragment = 'wc-fragment';\n\n/**\n * SSR\n */\nexport const ssr = (Component: WompComponent, props: WompProps = { styles: {} }) => {\n\t//! Handle styles\n\tconst render = Component(props);\n\tlet html = '';\n\tlet counter = 0;\n\tlet pendingTag = '';\n\tconst pending: number[] = [];\n\tconst components: {\n\t\tcomponent: WompComponent;\n\t\tprops: WompProps;\n\t}[] = [];\n\tfor (let i = 0; i < render.parts.length; i++) {\n\t\tlet part = render.parts[i];\n\t\tconst value = render.values[i];\n\t\tif (pendingTag && part.includes('>')) {\n\t\t\tconst firstPart = part.slice(0, part.indexOf('>') + 1);\n\t\t\tconst secondPart = part.slice(part.indexOf('>') + 1);\n\t\t\tif (firstPart[firstPart.length - 2] === '/') {\n\t\t\t\tpart = firstPart.slice(0, firstPart.length - 2) + `></${pendingTag}>` + secondPart;\n\t\t\t} else {\n\t\t\t\tpart = firstPart + `<?$WC${counter}>` + secondPart;\n\t\t\t\tpending.push(counter);\n\t\t\t\tpendingTag = '';\n\t\t\t\tcounter++;\n\t\t\t}\n\t\t}\n\t\tif (pending.length && part.endsWith('/') && value._$wompF) {\n\t\t\tconst before = part.slice(0, part.lastIndexOf('<'));\n\t\t\tpart = before + `</?$WC${pending.pop()}></`;\n\t\t\tpendingTag = '';\n\t\t}\n\t\thtml += part;\n\t\tconst isPrimitive = value !== Object(value);\n\t\tif (pendingTag) {\n\t\t\t//! Il valore \u00E8 una prop\n\t\t}\n\t\tif (isPrimitive && value) {\n\t\t\thtml += value;\n\t\t} else if (value?._$wompF) {\n\t\t\tif (!part.endsWith('/')) {\n\t\t\t\tcomponents.push({\n\t\t\t\t\tcomponent: value,\n\t\t\t\t\tprops: {\n\t\t\t\t\t\tstyles: {},\n\t\t\t\t\t},\n\t\t\t\t});\n\t\t\t\tpendingTag = value.componentName;\n\t\t\t}\n\t\t\thtml += value.componentName;\n\t\t}\n\t}\n\tfor (let i = components.length - 1; i >= 0; i--) {\n\t\tconst component = components[i];\n\t\tconst childrenRegex = new RegExp(`<\\\\?\\\\$WC${i}>(.*?)<\\\\/\\\\?\\\\$WC${i}>`, 'gs');\n\t\thtml = html.replace(childrenRegex, (_, group) => {\n\t\t\tcomponent.props.children = group;\n\t\t\tconst rendered = ssr(component.component, component.props);\n\t\t\treturn rendered;\n\t\t});\n\t}\n\treturn html;\n};\n"],
  "mappings": "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",
  "names": ["html", "dynamics", "startNode"]
}
