const $=!0;let x=null,g=0;const m="$wc$",T=/\s+([^\s]*?)="?$/g,E=/(<([a-x]*?-[a-z]*).*?)\/>/g,b=/<(?<tag>script|style|textarea|title])(?!.*?<\/\k<tag>)/gi,D=/^(?:script|style|textarea|title)$/i,f=0,y=1,p=document.createTreeWalker(document,129),M=c=>{const t=c.css||"",a=[];[...t.matchAll(/.*?}([\s\S]*?){/gm)].forEach(s=>{const i=s[1].trim();i.includes(".")||a.push(i)}),a.forEach(s=>{console.warn(`The CSS selector "${s} {...}" in the component "${c.componentName}" is not enough specific: include at least one class.
`)});const n=new Set;[...t.matchAll(/\.(.*?)[\s|{]/gm)].forEach(s=>{const i=s[1];n.add(i)});let e=t;return n.forEach(s=>{const i=`${c.componentName}__${s}`;e=e.replaceAll(s,i)}),e};//! HTML Nested fare il "join" delle dependencies
const A=c=>{let t="";const a=[],n=c.length-1;let e="",s="";for(let i=0;i<n;i++){let o=c[i];if(e&&o.includes(e)&&(e=""),s&&new RegExp(`</${s}>`)&&(s=""),e||s)t+=o+m;else{T.lastIndex=0;const l=T.exec(o);if(l){const[r,d]=l,u=r[r.length-2];e=u==='"'||u==="'"?u:"",o=o.substring(0,o.length-1);let h=`${o}${m}=`;e?h+=`"${m}`:h+='"0"',t+=h,a.push(d)}else{b.lastIndex=0;const r=b.exec(o);r?(s=r[1],t+=o+m):t+=o+`<?${m}>`}}}return t+=c[c.length-1],t=t.replace(E,"$1></$2>"),[t,a]},v=(c,t,a)=>{const n=[];p.currentNode=c.content;let e,s=0,i=0;const o=t.length;for(;(e=p.nextNode())!==null&&n.length<o;){if(e.nodeType===1){if(e.hasAttributes()){const l=e.getAttributeNames();for(const r of l)if(r.endsWith(m)){const d=a[s++],u=e.getAttribute(r),h={type:y,index:i,name:d};if(u!=="0"){const N=u.split(m);for(const L of N){const C={type:y,index:i,name:d};n.push(C)}}else n.push(h);e.removeAttribute(r)}}if(D.test(e.tagName)){const l=e.textContent.split(m),r=l.length-1;if(r>0){e.textContent="";for(let d=0;d<r;d++)e.append(l[d],document.createComment("")),p.nextNode(),n.push({type:f,index:++i});e.append(l[r],document.createComment(""))}}}else if(e.nodeType===8)if(e.data===`?${m}`)n.push({type:f,index:i});else{//! Capisci sta roba
}i++}return n};class H{constructor(t,a,n){this.isNode=!0;this.startNode=t,this.endNode=a,this.index=n}}class S{constructor(t,a,n){this.isNode=!1;this.eventInitialized=!1;this.node=t,this.name=a,this.index=n}set callback(t){if(!this.eventInitialized){const a=this.name.substring(1);this.node.addEventListener(a,this.listener.bind(this)),this.eventInitialized=!0}this._callback=t}listener(t){this._callback&&this._callback(t)}}class W{constructor(t,a){this.template=t,this.dependencies=a}clone(){const t=this.template.content,a=this.dependencies,n=document.importNode(t,!0);p.currentNode=n;let e=p.nextNode(),s=0,i=0,o=a[0];const l=[];for(;o!==void 0;){if(s===o.index){let r;o.type===f?r=new H(e,e.nextSibling,o.index):o.type===y&&(r=new S(e,o.name,o.index)),l.push(r),o=a[++i]}s!==o?.index&&(e=p.nextNode(),s++)}return p.currentNode=document,[n,l]}}const R=(c,t)=>{for(let a=0;a<c.length;a++){const n=c[a],e=t[a];if(n.isNode)n.startNode.after(e),n.endNode=e.nextSibling;else{const s=n.name;if(s.startsWith("@"))n.callback=e;else{const i=n.node;e===!1?i.removeAttribute(s):i.setAttribute(s,e)}}}},w=c=>class extends HTMLElement{constructor(){super();this.state=[];this.initElement()}static getOrCreateTemplate(n){if(!this.cachedTemplate){const[e,s]=A(n),i=document.createElement("template");i.innerHTML=e;const o=v(i,n,s);this.cachedTemplate=new W(i,o)}return this.cachedTemplate}connectedCallback(){}initElement(){this.ROOT=this,this.ROOT.innerHTML="",x=this,g=0;const n=c.call(this,{});let e=n;(typeof n=="string"||n instanceof HTMLElement)&&(e=html`${n}`);const{values:s,parts:i}=e,o=this.constructor.getOrCreateTemplate(i),[l,r]=o.clone();for(R(r,s);l.childNodes.length;)this.ROOT.appendChild(l.childNodes[0])}};export function defineWomp(c){const t=w(c);return customElements.define(c.componentName,t),t}export const useState=c=>{const t=x;if(!t.state.hasOwnProperty(g)){const n=g;t.state[n]={value:c,setter:e=>{t.state[n].value=e}}}const a=t.state[g];return g++,[a.value,a.setter]};export function html(c,...t){return{parts:c,values:t,__womp:!0}}
